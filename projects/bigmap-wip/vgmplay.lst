0000                1 ;;;;;;;;;;;;;;;;;
0000                2 ;;
0000                3 ;; Z80 VGM Player
0000                4 ;; 
0000                5 ;; v 0.23
0000                6 ; WARNING: 68k side addresses changed from a00080+ to a00100+
0000                7 ; Set to NTSC 
0000                8 ; Samples currently OFF while debugging
0000                9 ; Watch for macros
0000               10 
0000               11 ; by RetroDevDiscord
0000               12 
0000               13 ; Special thanks to: 
0000               14 ;  Stef 
0000               15 ;  vytah
0000               16 
0000               17 ;;; TO USE: 
0000               18 ; Set byte a00100 to 1 every vblank to play!
0000               19 ; read byte a00101 to see if song is playing or not.
0000               20 ; Set SongBaseAddress (102h-105h) to full 32bit address 
0000               21 ; and RomBank (106h) to bit 15+ of the 68000 memory bank
0000               22 ; If PAL, set the PAL flag to 1 (108h), otherwise, 0=NTSC
0000               23 
0000               24 ; TODOS:
0000               25 ; - Tie z80 to vblank interrupt so it isn't driven by 68000
0000               26 ; - Add error checking for vgm 1.60
0000               27 ; - weirder bytecodes 
0000               28 ; - multiple sample streams 
0000               29 ; - WIP: multiple data blocks
0000               30 
0000               31 ;;;;;
0000               32 ; FIXMEs
0000               33 ; - copy and paste CurDac stuff within dac loop 
0000               34 ; - dac block transfer size needs adjusting / delay based on sample width!
0000               35 
0000               36 
0000               37 FMREG0 EQU $4000
0000               38 FMDAT0 EQU $4001
0000               39 FMREG1 EQU $4002
0000               40 FMDAT1 EQU $4003
0000               41 BANKREG EQU $6000
0000               42 PSGREG EQU $7F11
0000               43 
0000               44 
0000               45 VGM_START EQU $00 
0000               46 VGM_END EQU $04       ;*: ; 2004-2005
0000               47 SSGCLOCK EQU $0C      ; : ; 200c-200f
0000               48 SAMPLECOUNT EQU $18   ;*:  ; 2018-201b 0X22740
0000               49 LOOPOFFSET EQU $1c    ;*: 201c-201f
0000               50 LOOPNUMS EQU $20      ;*:   ; 2020-2023
0000               51 RATE EQU $24          ;:   ; 2024-2027 = 60
0000               52 SNFB EQU $28          ;*?:  ; 2028-9 = 0009
0000               53 SNW EQU $2a           ;*?; 202a = 16
0000               54 SF EQU $2b            ;*:    ; 202b ; ssg flags all 0
0000               55 YM2612CLK EQU $2C     ;: ; 202c-202f = 0x750ab6 
0000               56 VGMDATOFS EQU $34     ;*:  ; 2034-2037
0000               57 ;SPCMCLK EQU $2038       ;:    ; 2038-203b
0000               58 ;SPCMI EQU $203C         ;:   ; 203c-203f
0000               59 VM EQU $7C            ;: volume modifier (default 0) ; 207c
0000               60 LB EQU $7E            ;: loop base; 207e
0000               61 LM EQU $7F            ;: loop modifier; 207f
0000               62         
0000               63         org $0
0000               64 
0000               65 ; disable interrupts
0000 f3            66         di 
0001               67 
0001               68 ; clear the stack
0001 3e 00         69         ld a, 0
0003 11 00 1c      70         ld de, $1c00 
0006 06 00         71         ld b, 0 
0008               72 _clrstack:
0008 12            73         LD (DE),A
0009 13            74         inc de 
000a 10 fc         75         djnz _clrstack
000c               76 _clr2
000c 12            77         ld (de),a 
000d 13            78         inc de 
000e 10 fc         79         djnz _clr2
0010               80 _clr3 
0010 12            81         ld (de),a 
0011 13            82         inc de 
0012 10 fc         83         djnz _clr3
0014               84 
0014               85 ; set the stack pointer 
0014 31 80 1d      86         ld sp,$1d80 
0017               87 
0017               88 ; clear and go!
0017 cd bf 07      89         call CLEARPSG 
001a cd f9 06      90         call BANKSWAP
001d               91 
001d c3 0c 01      92         jp LOADVGM 
0020               93         
0020               94 ; +8 and +9 should contain VGM version number.
0020               95 ;VERSIONCHECK:
0020               96 ;        ld hl, ($2008) 
0020               97 ;        cp h, $60
0020               98 ;        jr nz,WRONGVER
0020               99 ;        cp l, $01
0020              100 ;        jr nz,WRONGVER 
0020              101 ;        jp LOADVGM
0020              102 ;WRONGVER:
0020              103 ;        jp WRONGVER
0020              104 
0020              105 CLRTB:
0020 9f bf df ff  106         defb $9f,$bf,$df,$ff
0024              107 LoopPlay: 
0024 00           108         defb 0
0025              109 LoopLoc:        
0025 00 00 00 00  110         defb 0,0,0,0
0029              111 
0029 00 00 00 00  112 WORKRAM: defb 0,0,0,0
002d              113 
002d 00 00 00 00  114 SongDataStart: defb 0,0,0,0
0031              115 
0031              116 
0031              117 ; sub 50h then times 2
0031              118 CMDJUMPTABLE: ; starts at 50h
0031 78 07 00 00 27 07 53 07 00 00 00 00 00 00 00 00  119         defw WRITEPSG, 0, WRITEFM1, WRITEFM2, 0, 0, 0, 0 ; 50-57
0041 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  120         DEFW 0, 0, 0, 0, 0, 0, 0, 0 ;   58-5F
0051 00 00 86 07 be 01 be 01 00 00 00 00 e3 01 40 06  121         defw 0, SAMPLEWAIT, FRAMEOVER, FRAMEOVER, 0, 0, SONGOVER, DATABLOCK ; 60-67
0061 0a 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00  122         DEFW WRITEPCM, 0, 0, 0, 0, 0, 0, 0
0071 0e 02 0e 02 0e 02 0e 02 0e 02 0e 02 0e 02 0e 02  123         DEFW QWAIT, QWAIT, QWAIT, QWAIT, QWAIT, QWAIT, QWAIT, QWAIT ;70
0081 0e 02 0e 02 0e 02 0e 02 0e 02 0e 02 0e 02 0e 02  124         DEFW QWAIT, QWAIT, QWAIT, QWAIT, QWAIT, QWAIT, QWAIT, QWAIT ;7F   
0091 1c 02 1c 02 1c 02 1c 02 1c 02 1c 02 1c 02 1c 02  125         DEFW QFMWAIT, QFMWAIT, QFMWAIT, QFMWAIT, QFMWAIT, QFMWAIT, QFMWAIT, QFMWAIT
00a1 1c 02 1c 02 1c 02 1c 02 1c 02 1c 02 1c 02 1c 02  126         DEFW QFMWAIT, QFMWAIT, QFMWAIT, QFMWAIT, QFMWAIT, QFMWAIT, QFMWAIT, QFMWAIT ;..8f
00b1 b6 03 d9 03 1a 04 9f 04 8f 03 c1 04  127         DEFW DACSETUP, SETDACSTREAM, SETDACFREQ, STARTDACSTREAM, STOPDAC, DACFASTCALL ; 90-95
00bd d5 01        128         DEFW ERROR  ; 96
00bf              129 
00bf              130 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
00bf              131 
00bf              132         org $100
0100              133 
0100              134 ; Vars
0100              135 PlayNext:
0100 00           136         defb 0          ; 100h
0101              137 SongPlaying: 
0101 00           138         defb 0          ; 101h
0102              139 SongBaseAddress:        ; Set me when loading the song from the 68000!
0102 00 00 00 00  140         defb $0, $0, 0, 0 ; 102-105h
0106              141 RomBank:
0106 00           142         defb 0          ; 106h
0107              143 StartBank:
0107 00           144         defb 0          ; --
0108              145 ; This is 0 if NTSC, and 1 if PAL.
0108 00           146 PALFlag: defb 0         ; 108h
0109              147 ; Set this to 1 and the next frame the Z80 will reset (jp 0). 
0109              148 ; Do this after changing SongBaseAddress to change songs. 
0109 00           149 ResetFlag: defb 0       ; 109h
010a              150 
010a              151 FREECYCLES: ; 10Ah
010a 00 00        152         defw 0 
010c              153 
010c              154 LOADVGM:
010c              155 ;;;;;;;;;;;;;;;;
010c              156         
010c 3e 01        157         LD A,1 
010e 32 01 01     158         LD (SongPlaying),A      ; set playing var to ON
0111 3a 06 01     159         LD A,(RomBank) 
0114 32 07 01     160         LD (StartBank),A        ; Store the initial ROM bank for looping.
0117              161         
0117              162 ; Set the memory window to the song header (+1c)      
0117 2a 02 01     163         ld hl,(SongBaseAddress)
011a 01 1c 00     164         ld bc,$001c 
011d af           165         xor a 
011e ed 4a        166         adc hl,bc 
0120 22 1f 02     167         ld (ZadrWork),hl 
0123 2a 04 01     168         ld hl,(SongBaseAddress+2)
0126 01 00 00     169         ld bc,$0000
0129 ed 4a        170         adc hl,bc               ; catch the carry
012b 22 21 02     171         ld (ZadrWork+2),hl
012e cd 23 02     172         call SETZADDRESS        ; set bank to song base address + 1c!
0131              173 
0131              174 ; Is the loop variable = 00 00 ?
0131 7e           175         ld a,(hl)               ; pointer is at loop portion of header. 
0132 4f           176         ld c,a 
0133 23           177         inc hl                  ; +6
0134 7c           178         ld a,h                  ; +4
0135 e6 80        179         and $80                 ; +7
0137 cc 19 07     180         call z,BANKUP ; this also sets HL to 8000 +17/10
013a 7e           181         ld a,(hl)               ; Is there loop location?
013b b1           182         or c  
013c 28 4b        183         jr z, noloop            ; checks first two bytes only~~~
013e 7e           184         ld a,(hl)
013f 47           185         ld b,a                  ; 1c and 1d are in bc
0140              186 ; store the 32bit 68000 address at LoopLoc
0140 e5           187         push hl 
0141 c5           188          push bc 
0142 e1           189          pop hl 
0143 22 25 00     190          ld (LoopLoc),hl ; store 1c-1d here
0146 e1           191         pop hl          ; at LoopLoc
0147 23           192         inc hl                  ; +6
0148 7c           193         ld a,h                  ; +4
0149 e6 80        194         and $80                 ; +7
014b cc 19 07     195         call z,BANKUP ; this also sets HL to 8000 +17/10
014e 7e           196         ld a,(hl) 
014f 4f           197         ld c,a 
0150 23           198         inc hl                  ; +6
0151 7c           199         ld a,h                  ; +4
0152 e6 80        200         and $80                 ; +7
0154 cc 19 07     201         call z,BANKUP ; this also sets HL to 8000 +17/10
0157 7e           202         ld a,(hl) 
0158 47           203         ld b,a 
0159 c5           204         push bc         ; excg
015a e1           205         pop hl          ; bc and hl
015b 22 27 00     206         ld (LoopLoc+2),hl  ; and at LoopLoc+2
015e              207         ; WE AREN'T DONE!!!
015e              208 ; we need to convert this to the 68000 range.;
015e 2a 02 01     209         ld hl,(SongBaseAddress) 
0161 e5           210         push hl 
0162 c1           211         pop bc                  ; HL = LoopLoc+0, BC=SongBaseAddress+0 
0163 2a 25 00     212         ld hl,(LoopLoc) 
0166 af           213         xor a 
0167 ed 4a        214         adc hl,bc               ; if it overflows, its in the carry...
0169 22 25 00     215         ld (LoopLoc),hl         ; lower byte stored
016c 2a 27 00     216         ld hl,(LoopLoc+2)       ; load upper byte and store carry
016f 01 00 00     217         ld bc,$0000
0172 ed 4a        218         adc hl,bc               ; <- carry taken care of. 
0174 22 27 00     219         ld (LoopLoc+2),hl 
0177              220         ; HL = LoopLoc+2 and carry
0177 e5           221         push hl 
0178 2a 04 01     222          ld hl,(SongBaseAddress+2) 
017b e5           223          push hl 
017c c1           224          pop bc 
017d e1           225         pop hl    ; HL = LoopLoc+2+c, BC = SongBaseAddress+2
017e af           226         xor a     ; clear carry for the upper bytes 
017f ed 4a        227         adc hl,bc               ; phew! NOW we're good 
0181 22 27 00     228         ld (LoopLoc+2),hl 
0184              229 ; Set start playing flag 
0184 3e 01        230         ld a,1 
0186 32 24 00     231         ld (LoopPlay),a           ; set LoopPlay to 1
0189              232 noloop:
0189              233 ; Now set HL to song data pointer - longword at 0x0034 into the VGM header 
0189 2a 02 01     234         ld hl,(SongBaseAddress)    ; 00001ef7, need to add 83 to skip header and
018c              235                                    ; byte size
018c 01 80 00     236         ld bc, $0080      ; skip the header
018f af           237         xor a 
0190 ed 4a        238         adc hl,bc  ; 0x100              ; 1f2b 1f2e is wrong! should be 1f7a
0192 22 1f 02     239         ld (ZadrWork),hl           ; 16bit addition ; START BAD CODE
0195 01 00 00     240         ld bc,$0000
0198 2a 04 01     241         ld hl,(SongBaseAddress+2)
019b ed 4a        242         adc hl,bc ; catch the carry 
019d 22 21 02     243         ld (ZadrWork+2),hl              ; < ok
01a0 cd 23 02     244         call SETZADDRESS   
01a3              245 ; TODO FIXME i am not reading addr from header right now     
01a3              246 ; This means only 128-byte header VGMs (1.60 will work!)
01a3              247         ; hl now contains base+34 or data offset start
01a3              248 ; Get the 68000 address and store it in SongDataStart (our sram var) 
01a3 7e           249         ld a,(hl) ; data start offset bits 0-7. add this to ;
01a4              250 
01a4 2b           251         dec hl  ;) < go down one because we call GetNextSongByte below
01a5              252 PLAYLOOP:
01a5              253 ;;;;;;;;;;;;;;;;               ; +27..400
01a5 23           254         inc hl                  ; +6
01a6 7c           255         ld a,h                  ; +4
01a7 e6 80        256         and $80                 ; +7
01a9 cc 19 07     257         call z,BANKUP ; this also sets HL to 8000 +17/10
01ac 7e           258         LD A,(HL)
01ad              259         ; sub 50h, times 2 + &CMDJUMPTABLE
01ad 16 50        260         ld d,$50
01af 92           261         sub d 
01b0 cb 27        262         sla a ; a = (a-50)*2 + jumptab
01b2 01 31 00     263         ld bc,CMDJUMPTABLE 
01b5 81           264         add a,c   ; bc+a =>
01b6 4f           265         ld c,a    ;  de
01b7 0a           266         ld a,(bc) 
01b8 5f           267         ld e,a 
01b9 03           268         inc bc 
01ba 0a           269         ld a,(bc) 
01bb 57           270         ld d,a
01bc d5           271         push de 
01bd c9           272         ret 
01be              273 
01be              274 
01be              275 FRAMEOVER:
01be              276 ;;;;;;;;;;;
01be              277 ; * A
01be              278 ; Waits until next vblank signal (done via 68k)
01be              279         ;JP FRAMEOVER 
01be              280         ; Before checking 68k vbl, we need to see if DAC are queued.
01be              281         ;LD A,(DacTransferActive) 
01be              282         ;cp 0 
01be              283         ;call DACBLOCKTRANSFER ; MAD TESTING BRUH
01be 01 00 00     284         ld bc,0
01c1              285 _framewait:
01c1 03           286         inc bc 
01c2 3a 00 01     287         LD A,(PlayNext)  ; check the 'play next frame' var
01c5 fe 01        288         CP 1             ; is it = 1?
01c7 20 f8        289         JR NZ,_framewait  ; if not, loop.
01c9 af           290         xor a            ; if it is, clear it.
01ca 32 00 01     291         ld (PlayNext),a 
01cd ed 43 0a 01  292         ld (FREECYCLES),bc
01d1 c3 a5 01     293         JP PLAYLOOP 
01d4              294 ;;;; 
01d4              295 
01d4              296 
01d4              297 ;;;;;;;;;;;;;;;;;;;
01d4 99           298 ERRDEFB: DEFB $99
01d5              299 ; This error handling is super rudimentary and only intended to get songs to
01d5              300 ;  play without crashing!
01d5              301 ERROR:  
01d5              302         ;cp $28    ; probably just got lost 
01d5              303         ;jr _fixsongptr
01d5 c3 d5 01     304         jp ERROR 
01d8              305 
01d8              306 _fixsongptr: 
01d8 23           307         inc hl                  ; +6
01d9 7c           308         ld a,h                  ; +4
01da e6 80        309         and $80                 ; +7
01dc cc 19 07     310         call z,BANKUP ; this also sets HL to 8000 +17/10
01df c3 a5 01     311         jp PLAYLOOP 
01e2              312 
01e2 55           313 _songoverb: defb $55
01e3              314 SONGOVER:
01e3              315 ;;;;;;;;;;;
01e3              316 ; * A
01e3              317 ; Stops the song when hits command byte 0x66
01e3              318 ;  Or, if looping, jumps to loop
01e3 3a 24 00     319         ld a,(LoopPlay) 
01e6 fe 00        320         cp 0 
01e8 28 12        321         jr z, _endsong  
01ea              322 ; LOOP PLAY:
01ea              323         ; LoopLoc should be all set...
01ea 2a 25 00     324         ld hl,(LoopLoc) 
01ed 22 1f 02     325         ld (ZadrWork),hl 
01f0 2a 27 00     326         ld hl,(LoopLoc+2) 
01f3 22 21 02     327         ld (ZadrWork+2),hl 
01f6 cd 23 02     328         call SETZADDRESS 
01f9 c3 a5 01     329         jp PLAYLOOP
01fc              330 _endsong:
01fc af           331         XOR A 
01fd 32 01 01     332         LD (SongPlaying),A
0200 cd bf 07     333         call CLEARPSG
0203              334         ; TODO in case the VGM doesn't clear the FM stuff, do that here
0203              335 _overloop
0203 c3 03 02     336         JP _overloop
0206              337 
0206              338 
0206              339 ;GetNextSongByte:
0206              340 ;        inc hl 
0206              341 ;        ld a,h 
0206              342 ;        and $80 
0206              343 ;        call z,BANKUP ; this also sets HL to 8000
0206              344 ;        ret 
0206              345 
0206              346 
0206              347 VOLUMESET:
0206              348         ;JP PLAYLOOP  
0206 c3 06 02     349         JP VOLUMESET 
0209              350         
0209              351 
0209 11           352 aaa: defb $11
020a              353 WRITEPCM:
020a              354         ;jp PLAYLOOP  
020a c3 0a 02     355         JP WRITEPCM 
020d 22           356 bbb: defb $22
020e              357 ; Waits 1-16 samples
020e              358 QWAIT:
020e              359         ; TOO SHORT TO NOTICE?
020e e6 0f        360         and $0f 
0210 47           361         ld b,a 
0211 0e 00        362         ld c,0 
0213              363 _qwl:   ; idk what to do other than skip 256*n cycles
0213 0b           364         dec bc 
0214 79           365         ld a,c 
0215 b0           366         or b 
0216 20 fb        367         jr nz, _qwl
0218 c3 a5 01     368         JP PLAYLOOP 
021b 33           369 ccc: defb $33
021c              370 QFMWAIT:
021c              371         ;jp PLAYLOOP 
021c c3 1c 02     372         JP QFMWAIT 
021f              373 
021f 00 00 00 00  374 ZadrWork: defb 0,0,0,0
0223              375 
0223              376 SETZADDRESS:
0223              377 ;;;;;;;;;;;;;;;;;;
0223              378 ; * A H L 
0223              379 ; Input: ZadrWork 32-bit address (68000 memory)
0223              380 ; Output: changes active rom bank, and sets HL to mem addr
0223 2a 20 02     381         ld hl,(ZadrWork+1) ; ignore bits 0-7, so we have 8-23
0226 af           382         xor a ; clc 
0227 cb 3c        383         srl h
0229 cb 1d        384         rr l   ; hl >> 1
022b cb 3c        385         srl h
022d cb 1d        386         rr l   ; hl >> 2
022f cb 3c        387         srl h
0231 cb 1d        388         rr l   ; hl >> 3
0233 cb 3c        389         srl h
0235 cb 1d        390         rr l   ; hl >> 4
0237 cb 3c        391         srl h
0239 cb 1d        392         rr l   ; hl >> 5
023b cb 3c        393         srl h
023d cb 1d        394         rr l   ; hl >> 6
023f cb 3c        395         srl h
0241 cb 1d        396         rr l   ; hl >> 7 
0243 7d           397         ld a,l 
0244 32 06 01     398         ld (RomBank),a ; BITS 15-22
0247 cd f9 06     399         call BANKSWAP
024a 2a 1f 02     400         LD HL,(ZadrWork)  ; 0-15 
024d 3e 7f        401         ld a,$7f 
024f a4           402         and h 
0250 f6 80        403         or $80 ; always set top bit so we look at $8000 + 
0252 67           404         ld h,a
0253 e5           405         push hl 
0254 21 00 00     406         ld hl,$0000 
0257 22 1f 02     407         ld (ZadrWork),hl 
025a 22 21 02     408         ld (ZadrWork+2),hl 
025d e1           409         pop hl 
025e              410         ; [HL] now contains memory pointer!
025e c9           411         ret
025f              412 ;;;;
025f              413 
025f              414 GETROMADDRESS: 
025f              415 ;;;;;;;;;;;;;;
025f              416 ; INPUT: ZadrWork+0 BANK
025f              417 ;        ZadrWork+2~ZadrWork+3 HL
025f              418 ; (bank * 8000) + HL & 7fff
025f              419 ; OUTPUT: ZadrWork ~ ZadrWork+3 CONTAINS LONGWORD ADDRESS
025f              420 ; * A
025f              421 ; Preserves HL
025f e5           422         push hl
0260 c5           423         push bc  
0261 af           424          xor a ; clc 
0262 3a 1f 02     425          ld a,(ZadrWork) ; contains RomBank, A15-A22
0265              426          ; 15:
0265 e6 01        427          and $1 
0267 cb 1f        428          rr a   ; 15 > carry 
0269 cb 1f        429          rr a   ; carry > 7, carry = 0
026b 47           430          ld b,a ; contains bit 15 ; SAVE
026c 3a 1f 02     431          ld a,(ZadrWork) ; 15-22...
026f e6 fe        432          and $fe
0271 cb 3f        433          srl a    ; and the last bit and shift RIGHT, so we have 16-23 (minus23)
0273 2a 21 02     434          ld hl,(ZadrWork+2) 
0276 32 21 02     435          ld (ZadrWork+2),a ; put it in the 3rd byte 
0279 af           436          xor a 
027a 32 1f 02     437          ld (ZadrWork),a 
027d 32 20 02     438          ld (ZadrWork+1),a ; zero the first two
0280              439          
0280 3e 7f        440          ld a,$7f 
0282 a4           441          and h ; hl = bits 0-14, dont forget 15 in b!
0283 b0           442          or b           ; d(>.< )
0284 67           443          ld h,a
0285 22 1f 02     444          ld (ZadrWork),hl 
0288 af           445          xor a 
0289 32 22 02     446          ld (ZadrWork+3),a ; 24-31 are always 0
028c c1           447         pop bc 
028d e1           448         pop hl 
028e c9           449         RET 
028f              450 
028f 00 00        451 DacWRAM: defb 0, 0
0291              452 DACWORK
0291 00 00 00 00  453         defb 0,0,0,0
0295              454 ; Block struct:
0295              455 ;Type (ff means empty) 1
0295              456 ; Compatible types:
0295              457 ; 0: YM2612 PCM data 
0295              458 ;Size 4
0295              459 ; 32 bit size (from VGM file)
0295              460 ;Loc 2 (HL offset of data start)
0295              461 ;Bank 1 (bank of data start)
0295              462 ;Counter 4 (32bit offset remaining to play of this loop)
0295              463 ;BlockActive: 1 if we need to dac stream it, 0 skips
0295              464 ;_buffer 3 : to align to 16 bytes
0295              465 
0295              466 DACBLOCKTRANSFER:
0295              467         ;ret 
0295              468 ;; Step through me again
0295              469         ; PRESERVE CURRENT ROM BANK AND SONG PTR IN WORKRAM~+3
0295 3a 06 01     470         ld a,(RomBank)          
0298 32 91 02     471         ld (DACWORK),a 
029b af           472         xor a
029c 32 92 02     473         ld (DACWORK+1),a     ; saving me for later!
029f 22 93 02     474         ld (DACWORK+2),hl       
02a2              475         ; LOOP THROUGH DATA STRUCT[], SEARCH FOR ACTIVE BYTE == 1
02a2              476 ;        ld hl,BlockActive-16
02a2              477 ;        ld b,16   ; 16 data arrays
02a2              478 ;        ld de,1  ; 16 bytes each FIXME
02a2              479 ;_nextdb
02a2              480 ;        OR A 
02a2              481 ;        adc hl,de 
02a2              482 ;        ld a,(hl) 
02a2              483 ;        cp $0
02a2              484 ;        jr nz,_found
02a2              485 ;        djnz _nextdb
02a2              486 ;        cp $0 
02a2              487 ;        jp z,_daclpend     ; if all are 0, return
02a2              488 _found
02a2              489         ; TESTING 
02a2 3a 4a 05     490         ld a,(BlockActive) 
02a5 fe 00        491         cp 0 
02a7 c8           492         ret z 
02a8              493         ; b = 15 to 0 (to flip: 15 - b)
02a8              494         ;ld hl,15 
02a8              495         ;ld c,0
02a8              496         ;or a 
02a8              497         ;sbc hl,bc 
02a8              498         ;ld a,l
02a8              499         ; now [A] has active data bank 0-15
02a8              500         ; TODO 
02a8              501         ; GET THE STRUCT'S CTR, STORE IT IN ACTIVEDACCTR
02a8              502         ; switch to ActiveDacBank|ActiveDacLoc 
02a8 3a bf 04     503         ld a,(ActiveDacBank)     ; = 0
02ab 32 06 01     504         ld (RomBank),a 
02ae cd f9 06     505         call BANKSWAP 
02b1              506         ; output 267 bytes from the bank (TODO DacFrequency)
02b1              507         ; 1. CHECK ACTIVEDACCTR+2~3 - IF > 0, BC = $10B
02b1              508         ; 2. COMPARE ADC+0~1 WITH $10B - IF >, BC=$10B
02b1              509         ;    ELSE BC = ADC+0~1
02b1              510         ; STORE BC IN DACWRAM   
02b1 3a 00 40     511         LD A,($4000) 
02b4 87           512         ADD A, A 
02b5 38 fc        513         JR C,-4
02b7 3e 2b        514         ld a,$2b 
02b9 32 00 40     515         ld ($4000),a 
02bc 3a 00 40     516         LD A,($4000) 
02bf 87           517         ADD A, A 
02c0 38 fc        518         JR C,-4
02c2 3e 80        519         ld a,$80 
02c4 32 01 40     520         ld ($4001),a 
02c7 2a bb 04     521         LD HL,(ActiveDacCtr+2) 
02ca 7c           522         LD A,H 
02cb b5           523         or L 
02cc 20 1a        524         JR NZ,_norm   ; if either of the two high bytes are > 0, normal.
02ce              525         
02ce ed 4b b9 04  526         ld bc,(ActiveDacCtr) 
02d2 3a 00 04     527         ld a,(DacFrequency)
02d5 91           528         sub c 
02d6 3a 01 04     529         ld a,(DacFrequency+1)
02d9 98           530         sbc a,b 
02da 38 0c        531         jr c,_norm 
02dc              532         ; else, short dac 
02dc ed 4b b9 04  533         ld bc,(ActiveDacCtr) 
02e0 79           534         ld a,c 
02e1 b0           535         or b
02e2 ca 3c 03     536         jp z,_enddac
02e5 c3 e8 02     537         jp _nr
02e8              538 _norm:
02e8              539         ;ld bc,(DacFrequency) ;; (DacFrequency) ; hopefully 267: debug me
02e8              540 _nr:
02e8              541         ;LD BC,765
02e8 ed 43 8f 02  542         ld (DacWRAM),bc 
02ec 2a bd 04     543         ld hl,(ActiveDacLoc) ; already -1!
02ef              544 dacwriteloop:
02ef 3a 00 40     545         LD A,($4000) 
02f2 87           546         ADD A, A 
02f3 38 fc        547         JR C,-4
02f5 3e 2a        548         ld a,$2a
02f7 32 00 40     549         ld ($4000),a
02fa 23           550         inc hl                  ; +6
02fb 7c           551         ld a,h                  ; +4
02fc e6 80        552         and $80                 ; +7
02fe cc 19 07     553         call z,BANKUP ; this also sets HL to 8000 +17/10
0301 3a 00 40     554         LD A,($4000) 
0304 87           555         ADD A, A 
0305 38 fc        556         JR C,-4
0307 7e           557         ld a,(hl)
0308 32 01 40     558         ld ($4001),a 
030b              559         
030b 0b           560         dec bc
030c 79           561         ld a,c 
030d b0           562         or b 
030e 20 df        563         jr nz,dacwriteloop ; a360 bank 0
0310              564         ; 3. SUBTRACT DACWRAM FROM ADC (32BIT-16BIT)
0310 3a 06 01     565         ld a,(RomBank) 
0313 32 bf 04     566         ld (ActiveDacBank),a ; may be unnecessary 
0316 22 bd 04     567         ld (ActiveDacLoc),hl 
0319              568         
0319 b7           569         or a ; clc 
031a e5           570         push hl 
031b c5           571          push bc 
031c 2a b9 04     572           ld hl,(ActiveDacCtr) 
031f ed 4b 8f 02  573           ld bc,(DacWRAM) 
0323 b7           574           or a  ; clc 
0324 ed 42        575           sbc hl,bc 
0326 22 b9 04     576           ld (ActiveDacCtr),hl 
0329 ca 3c 03     577           jp z,_enddac 
032c f2 43 03     578           jp p,_nouflow
032f da 3c 03     579           jp c,_enddac 
0332              580           ; else dec adc+2 
0332 2a bb 04     581           ld hl,(ActiveDacCtr+2) 
0335 2b           582           dec hl 
0336 22 bb 04     583           ld (ActiveDacCtr+2),hl 
0339              584         ; 4. IF ADC UNDERFLOWS, END DAC (or check loop if its there)
0339 f2 43 03     585           jp p,_nouflow ; if < 0, we're done with this. 
033c              586 _enddac:
033c cd 67 03     587           CALL QUICKSTOP
033f af           588           xor a 
0340 32 ff 03     589           ld (DacTransferActive),a 
0343              590 _nouflow: 
0343 c1           591          pop bc 
0344 e1           592         pop hl 
0345              593 _daclpend:
0345 3a 00 40     594         LD A,($4000) 
0348 87           595         ADD A, A 
0349 38 fc        596         JR C,-4
034b 3e 2b        597         ld a,$2b 
034d 32 00 40     598         ld ($4000),a
0350 3a 00 40     599         LD A,($4000) 
0353 87           600         ADD A, A 
0354 38 fc        601         JR C,-4
0356 af           602         xor a
0357 32 01 40     603         ld ($4001),a 
035a              604         
035a 3a 91 02     605         ld a,(DACWORK) 
035d 32 06 01     606         ld (RomBank),a 
0360 cd f9 06     607         call BANKSWAP 
0363 2a 93 02     608         ld hl,(DACWORK+2) 
0366              609         ; dont get next song byte outside the loop.
0366 c9           610         ret 
0367              611 ;;;;
0367              612 
0367              613 QUICKSTOP:
0367              614 ; TODO 
0367              615 ; get the active dac block (this is set inside the transfer each loop)
0367              616 ;  (ActiveDacBlock) is not used anywhere else
0367              617 ; set that block's "active" byte and counter to 0
0367 3a b8 04     618         ld a,(ActiveDacBlock)   ; ? 
036a e5           619         push hl 
036b c5           620          push bc 
036c cd a1 04     621           call GETBLOCKSTRUCT
036f 01 0c 00     622           ld bc,12 ; +12 = ACTIVE BYTE 
0372 b7           623           or a 
0373 ed 4a        624           adc hl,bc 
0375 af           625           xor a 
0376 77           626           ld (hl),a 
0377              627           ;ld (DacTransferActive),a 
0377              628           ;ld (ActiveDacBank),a 
0377 c1           629          pop bc 
0378 e1           630         pop hl 
0379              631         ;?
0379 32 b8 04     632         ld (ActiveDacBlock),a 
037c 32 b9 04     633         ld (ActiveDacCtr),a 
037f 32 ba 04     634         ld (ActiveDacCtr+1),a 
0382 32 bb 04     635         ld (ActiveDacCtr+2),a 
0385 32 bc 04     636         ld (ActiveDacCtr+3),a 
0388 32 bd 04     637         ld (ActiveDacLoc),a 
038b 32 be 04     638         ld (ActiveDacLoc+1),a 
038e              639 ;       block transfer method takes care of turning off DAC mode 
038e c9           640         RET 
038f              641 
038f              642 STOPDAC:
038f              643 ;;;;;;;;;;;;;;
038f              644 ; Stops DAC and disables DAC mode on CH6
038f              645 ; FIXME broken ?
038f 23           646         inc hl                  ; +6
0390 7c           647         ld a,h                  ; +4
0391 e6 80        648         and $80                 ; +7
0393 cc 19 07     649         call z,BANKUP ; this also sets HL to 8000 +17/10
0396              650         ; unused 
0396 af           651         xor a 
0397 32 ff 03     652         ld (DacTransferActive),a 
039a 32 bf 04     653         ld (ActiveDacBank),a 
039d 32 b8 04     654         ld (ActiveDacBlock),a 
03a0 32 b9 04     655         ld (ActiveDacCtr),a 
03a3 32 ba 04     656         ld (ActiveDacCtr+1),a 
03a6 32 bb 04     657         ld (ActiveDacCtr+2),a 
03a9 32 bc 04     658         ld (ActiveDacCtr+3),a 
03ac 32 bd 04     659         ld (ActiveDacLoc),a 
03af 32 be 04     660         ld (ActiveDacLoc+1),a 
03b2              661         ;call ZWAIT 
03b2              662         ;ld a,$2b 
03b2              663         ;ld ($4000),a 
03b2              664         ;call ZWAIT 
03b2              665         ;xor a 
03b2              666         ;;ld ($4001),a 
03b2 c3 a5 01     667         jp PLAYLOOP  
03b5              668 ;;;
03b5              669 
03b5 00           670 StreamID: defb 0
03b6              671 ; 90 0 2 0 2a 
03b6              672 ; TODO SUPPORT MORE THAN ONE DAC STREAM :)
03b6              673 DACSETUP:
03b6              674         ;INC HL  ; STREAM ID 
03b6 23           675         inc hl                  ; +6
03b7 7c           676         ld a,h                  ; +4
03b8 e6 80        677         and $80                 ; +7
03ba cc 19 07     678         call z,BANKUP ; this also sets HL to 8000 +17/10
03bd              679         ; 0 
03bd 7e           680         LD A,(HL) 
03be 32 b5 03     681         LD (StreamID),A 
03c1              682         ; We only want DAC mode on while transferring, so we leave that to
03c1              683         ; the block transfer method
03c1              684         ;INC HL  ; CHIP TYPE 
03c1 23           685         inc hl                  ; +6
03c2 7c           686         ld a,h                  ; +4
03c3 e6 80        687         and $80                 ; +7
03c5 cc 19 07     688         call z,BANKUP ; this also sets HL to 8000 +17/10
03c8              689         ; 2 
03c8              690         ;LD A,(HL) ; for genesis this should only ever be 02
03c8              691         ;CP 2
03c8              692         ;JR NZ,fail
03c8              693         ; I ignore these two bytes because VGM files appear to have
03c8              694         ; discrepency over the byte order.
03c8 23           695         inc hl                  ; +6
03c9 7c           696         ld a,h                  ; +4
03ca e6 80        697         and $80                 ; +7
03cc cc 19 07     698         call z,BANKUP ; this also sets HL to 8000 +17/10
03cf              699         ; write this byte 
03cf 23           700         inc hl                  ; +6
03d0 7c           701         ld a,h                  ; +4
03d1 e6 80        702         and $80                 ; +7
03d3 cc 19 07     703         call z,BANKUP ; this also sets HL to 8000 +17/10
03d6              704         ; to this reg
03d6              705         
03d6 c3 a5 01     706         jp PLAYLOOP 
03d9              707 
03d9              708 SETDACSTREAM:        
03d9              709 ; 0X91 <STREAM> <DATABANK ID> <STEP SIZE> <STEP BASE>
03d9              710 ;         0           0            1           0 
03d9              711 ; Preserves BC 
03d9 c5           712        push bc 
03da 23           713         inc hl                  ; +6
03db 7c           714         ld a,h                  ; +4
03dc e6 80        715         and $80                 ; +7
03de cc 19 07     716         call z,BANKUP ; this also sets HL to 8000 +17/10
03e1              717         ; Stream ID is for multiple DAC channels.
03e1              718         ; Genesis only supports one, so we skip it
03e1 23           719         inc hl                  ; +6
03e2 7c           720         ld a,h                  ; +4
03e3 e6 80        721         and $80                 ; +7
03e5 cc 19 07     722         call z,BANKUP ; this also sets HL to 8000 +17/10
03e8              723         ; Databank
03e8              724         ; Set the active block
03e8 7e           725         ld a,(hl) 
03e9              726         ;ld (ActiveDacBlock),a 
03e9              727         ; always call DAC TRANSFER every frame, but loop it through the 
03e9              728         ;  data structs instead to find Active Byte = 1
03e9              729         ;push hl 
03e9              730          ;call GETBLOCKSTRUCT
03e9              731          ;or a 
03e9              732          ;ld bc,12 
03e9              733          ;adc hl,bc 
03e9              734          ;push hl 
03e9              735          ;pop bc 
03e9              736         ;pop hl   ; HL = song ptr, BC = address of block A active byte 
03e9              737         ;LD A,1
03e9              738         ;LD (BC),A 
03e9              739 
03e9 23           740         inc hl                  ; +6
03ea 7c           741         ld a,h                  ; +4
03eb e6 80        742         and $80                 ; +7
03ed cc 19 07     743         call z,BANKUP ; this also sets HL to 8000 +17/10
03f0 23           744         inc hl                  ; +6
03f1 7c           745         ld a,h                  ; +4
03f2 e6 80        746         and $80                 ; +7
03f4 cc 19 07     747         call z,BANKUP ; this also sets HL to 8000 +17/10
03f7 c1           748        pop bc 
03f8              749 
03f8 c3 a5 01     750         jp PLAYLOOP  
03fb              751 
03fb              752 _invfreq
03fb 88           753         defb $88
03fc c3 fc 03     754 INVALIDFREQ: JP INVALIDFREQ 
03ff              755 
03ff              756 DacTransferActive: 
03ff 00           757         defb 0
0400              758 DacFrequency:
0400 00 00        759         defb 0, 0
0402              760 RealFrequency: 
0402 00 00 00 00  761         defb 0,0,0,0
0406              762 
0406              763 ; 
0406              764 FreqTable:
0406 86 00 b8 00 0b 01 70 01 15 02  765         DEFW 134,184,267,368,533
0410              766 PALFreqTable:
0410 a0 00 dd 00 40 01 b9 01 80 02  767         DEFW 160,221,320,441,640
041a              768 
041a              769 ; $92
041a              770 SETDACFREQ: ; 7D00 == 32000
041a              771 ; 7D00 = 32000 = 533 N 640P ; 
041a              772 ; 5622 = 22050 = 368 N 441P ; 
041a              773 ; 3E80 = 16000 = 267 N 320P ; 
041a              774 ; 2b11 = 11025 = 184 N 221P
041a              775 ; 1f40 = 8000 =  134 N 160P
041a 23           776         inc hl                  ; +6
041b 7c           777         ld a,h                  ; +4
041c e6 80        778         and $80                 ; +7
041e cc 19 07     779         call z,BANKUP ; this also sets HL to 8000 +17/10
0421 23           780         inc hl                  ; +6
0422 7c           781         ld a,h                  ; +4
0423 e6 80        782         and $80                 ; +7
0425 cc 19 07     783         call z,BANKUP ; this also sets HL to 8000 +17/10
0428 7e           784         ld a,(hl) 
0429 32 02 04     785         ld (RealFrequency),a 
042c 23           786         inc hl                  ; +6
042d 7c           787         ld a,h                  ; +4
042e e6 80        788         and $80                 ; +7
0430 cc 19 07     789         call z,BANKUP ; this also sets HL to 8000 +17/10
0433 7e           790         ld a,(hl) 
0434 32 03 04     791         ld (RealFrequency+1),a
0437 23           792         inc hl                  ; +6
0438 7c           793         ld a,h                  ; +4
0439 e6 80        794         and $80                 ; +7
043b cc 19 07     795         call z,BANKUP ; this also sets HL to 8000 +17/10
043e 23           796         inc hl                  ; +6
043f 7c           797         ld a,h                  ; +4
0440 e6 80        798         and $80                 ; +7
0442 cc 19 07     799         call z,BANKUP ; this also sets HL to 8000 +17/10
0445              800 
0445 e5           801         push hl 
0446 d5           802         push de 
0447              803 
0447 3a 08 01     804         ld a,(PALFlag)
044a fe 01        805         cp 1
044c 20 05        806         jr nz,__2 
044e 21 10 04     807         ld hl,PALFreqTable
0451 18 03        808         jr __1
0453              809 __2
0453 21 06 04     810         ld hl,FreqTable
0456              811 __1
0456 3a 03 04     812         ld a,(RealFrequency+1)               ; high byte of real freq is all we care about        
0459 fe 1f        813         cp $1f
045b 28 13        814         jr z,_set8
045d fe 2b        815         cp $2b 
045f 28 11        816         jr z,_set11
0461 fe 3e        817         cp $3e 
0463 28 15        818         jr z,_set16 
0465 fe 56        819         cp $56 
0467 28 19        820         jr z,_set22 
0469 fe 7d        821         cp $7d 
046b 28 1d        822         jr z,_set32 
046d c3 fc 03     823         jp INVALIDFREQ 
0470              824 _set8:
0470 18 1e        825         jr _endfset
0472              826 _set11:
0472 b7           827         or a 
0473 11 02 00     828         ld de,2 
0476 ed 5a        829         adc hl,de 
0478 18 16        830         jr _endfset
047a              831 _set16:
047a b7           832         or a 
047b 11 04 00     833         ld de,4 
047e ed 5a        834         adc hl,de 
0480 18 0e        835         jr _endfset
0482              836 _set22:
0482 b7           837         or a 
0483 11 06 00     838         ld de,6 
0486 ed 5a        839         adc hl,de 
0488 18 06        840         jr _endfset
048a              841 _set32:
048a b7           842         or a 
048b 11 08 00     843         ld de,8 
048e ed 5a        844         adc hl,de 
0490              845 
0490              846 _endfset
0490 7e           847         ld a,(hl) 
0491 32 00 04     848         ld (DacFrequency),a  
0494 23           849         inc hl 
0495 7e           850         ld a,(hl) 
0496 3c           851         inc a  ; FIXME 
0497 32 01 04     852         ld (DacFrequency+1),a 
049a              853         
049a d1           854         pop de
049b e1           855         pop hl 
049c              856         ;call GetNextSongByte ; (theres an extra 0?)
049c              857 
049c c3 a5 01     858         jp PLAYLOOP 
049f              859 
049f              860 
049f              861 ;;;;;;;;;;;;;;;;;
049f              862 STARTDACSTREAM:
049f              863 ;        inc hl  ; stream id 
049f              864         ; TODO NOT USED IN MY EXAMPLES
049f 18 fe        865         JR STARTDACSTREAM
04a1              866 
04a1              867 GETBLOCKSTRUCT:
04a1              868 ;;;;;;;;;;;;;;;;;;
04a1              869 ; IN: [A]
04a1              870 ; OUT: HL
04a1              871 ; PRESERVES BC 
04a1              872 ; * A H L 
04a1 c5           873         push bc 
04a2 21 3e 05     874         ld hl,DataType ; block 0 byte 0
04a5 cb 27        875         sla a ; * 2
04a7 cb 27        876         sla a ; * 4
04a9 cb 27        877         sla a ; * 8 
04ab cb 27        878         sla a ; * 16  ; we are 16 bytes large 
04ad 85           879         add a,l   ; carry?
04ae 6f           880         ld l,a 
04af 3e 00        881         ld a,0 
04b1 4f           882         ld c,a 
04b2 06 00        883         ld b,0   ; < this is to preserve carry 
04b4 ed 4a        884         adc hl,bc ; HL now has (DataType) + blockID*8
04b6 c1           885         pop bc 
04b7 c9           886         RET 
04b8              887 
04b8              888 ; 95 00 (0-15) 00
04b8 00           889 ActiveDacBlock: defb 0  ; which block 0-15 stored below
04b9 00 00 00 00  890 ActiveDacCtr: defb 0,0,0,0 ; 32bit count
04bd 00 00        891 ActiveDacLoc: defb 0,0  ; what is the memory offset
04bf 00           892 ActiveDacBank: defb 0   ; which 68000 memory bank
04c0 00           893 LoopDac: defb 0
04c1              894 
04c1              895 DACFASTCALL:
04c1              896 ;;;;;;;;;;;;;;;;;;;;;;;;
04c1              897 ; This should start the DAC playback
04c1              898 ; 95 00 
04c1              899 ; for data block info:
04c1              900 ; data type 1
04c1              901 ; datasize 4
04c1              902 ; dataloc 2  (hl) 
04c1              903 ; databank 1 (rom)
04c1              904 ; datacounter 4 (bytes left this loop)
04c1              905 ; blockactive 1 (gogogo)
04c1              906 ; 0X95
04c1 23           907         inc hl                  ; +6
04c2 7c           908         ld a,h                  ; +4
04c3 e6 80        909         and $80                 ; +7
04c5 cc 19 07     910         call z,BANKUP ; this also sets HL to 8000 +17/10
04c8              911         ;ld a, 1
04c8              912         ;ld (DacTransferActive),a  ; SET TRANSFER TO ACTIVE SO WE DO IT LOL
04c8 23           913         inc hl                  ; +6
04c9 7c           914         ld a,h                  ; +4
04ca e6 80        915         and $80                 ; +7
04cc cc 19 07     916         call z,BANKUP ; this also sets HL to 8000 +17/10
04cf 7e           917         ld a,(hl)       ; [A] contains block ID 
04d0 87           918         add a,a 
04d1 20 5a        919         jr nz, _nope  ; FIXME: ONE STREAM FOR NOW
04d3              920         ; warning! only have ram for 0-15!
04d3 32 b8 04     921         ld (ActiveDacBlock),a ; low byte 
04d6 e5           922         push hl 
04d7 cd a1 04     923          call GETBLOCKSTRUCT
04da e5           924          push HL 
04db c1           925          pop bc ; put it in BC
04dc e1           926         pop hl ; recover song pointer 
04dd 23           927         inc hl                  ; +6
04de 7c           928         ld a,h                  ; +4
04df e6 80        929         and $80                 ; +7
04e1 cc 19 07     930         call z,BANKUP ; this also sets HL to 8000 +17/10
04e4              931         ;ld a,(bc) ; data type
04e4 03           932         INC BC 
04e5 03           933         INC BC 
04e6 03           934         INC BC 
04e7 03           935         INC BC  ; SKIP FOUR SIZE BYTES
04e8              936 
04e8 03           937         inc bc 
04e9 0a           938         ld a,(bc) 
04ea              939 ;        LD E,4 
04ea              940 ;        ADD A,E 
04ea 32 bd 04     941         ld (ActiveDacLoc),a 
04ed 03           942         inc bc         
04ee 0a           943         ld a,(bc)
04ef              944 ;        ADC A,0 
04ef 32 be 04     945         ld (ActiveDacLoc+1),a ; 16bit dac offset ;a1e0
04f2              946 
04f2 03           947         inc bc 
04f3 0a           948         ld a,(bc) ; data rom bank #
04f4 32 bf 04     949         ld (ActiveDacBank),a 
04f7              950 
04f7 d5           951         push de 
04f8 03           952         inc bc 
04f9 0a           953         ld a,(bc) ; CTR+0
04fa 57           954         ld d,a 
04fb 32 b9 04     955         ld (ActiveDacCtr),a 
04fe 03           956         inc bc 
04ff 0a           957         ld a,(bc) 
0500 32 ba 04     958         ld (ActiveDacCtr+1),a 
0503 b2           959         or d 
0504 57           960         ld d,a 
0505 03           961         inc bc 
0506 0a           962         ld a,(bc) 
0507 32 bb 04     963         ld (ActiveDacCtr+2),a 
050a b2           964         or d 
050b 57           965         ld d,a 
050c 03           966         inc bc 
050d 0a           967         ld a,(bc) 
050e 32 bc 04     968         ld (ActiveDacCtr+3),a ; store 32bit dac size
0511 b2           969         or d 
0512 fe 00        970         cp 0 
0514 20 04        971         jr nz,_active
0516              972 _inactive 
0516 03           973         inc bc 
0517 af           974         xor a 
0518 18 03        975         jr _setblockon
051a              976 _active
051a 03           977         inc bc 
051b 3e 01        978         ld a,1
051d              979 _setblockon
051d 02           980         ld (bc),a 
051e d1           981         pop de 
051f              982         ;INC HL          ; FLAGS 
051f 23           983         inc hl                  ; +6
0520 7c           984         ld a,h                  ; +4
0521 e6 80        985         and $80                 ; +7
0523 cc 19 07     986         call z,BANKUP ; this also sets HL to 8000 +17/10
0526 7e           987         ld a, (hl)      ; AM I LOOPING?
0527 32 c0 04     988         ld (LoopDac),a  ; FIXME - NO LOOP FOR NOW
052a              989         ; enable!
052a c3 a5 01     990         jp PLAYLOOP 
052d              991 _nope: 
052d 23           992         inc hl                  ; +6
052e 7c           993         ld a,h                  ; +4
052f e6 80        994         and $80                 ; +7
0531 cc 19 07     995         call z,BANKUP ; this also sets HL to 8000 +17/10
0534 23           996         inc hl                  ; +6
0535 7c           997         ld a,h                  ; +4
0536 e6 80        998         and $80                 ; +7
0538 cc 19 07     999         call z,BANKUP ; this also sets HL to 8000 +17/10
053b c3 a5 01    1000         jp PLAYLOOP
053e             1001 
053e             1002 ; Data Block struct:
053e ff          1003 DataType: defb $ff
053f 00 00 00 00 1004 DataSize: defb 0,0,0,0
0543 00 00       1005 DataLoc: defb 0,0
0545 00          1006 DataBank: defb 0
0546 00 00 00 00 1007 DataCounter: defb 0,0,0,0 
054a 00          1008 BlockActive: defb 0
054b 00 00 00    1009 _buffer: defb 0,0,0          ; 16 bytes 
054e             1010 ;Type (ff means empty) 1
054e             1011 ; Compatible types:
054e             1012 ; 0: YM2612 PCM data 
054e             1013 ;Size 4
054e             1014 ; 32 bit size (from VGM file)
054e             1015 ;Loc 2 (HL offset of data start)
054e             1016 ;Bank 1 (bank of data start)
054e             1017 ;Counter 4 (32bit offset remaining to play of this loop)
054e             1018 ;BlockActive: 1 if we need to dac stream it, 0 skips
054e             1019 ;_buffer 3 : to align to 16 bytes
054e ff 00 00 00 00 00 00 00 1020 Block1: defb $ff,0,0,0,0,0,0,0
0556 00 00 00 00 00 00 00 00 1021         defb $0,0,0,0,0,0,0,0
055e ff 00 00 00 00 00 00 00 1022 Block2: defb $ff,0,0,0,0,0,0,0
0566 00 00 00 00 00 00 00 00 1023         defb $0,0,0,0,0,0,0,0
056e ff 00 00 00 00 00 00 00 1024 Block3: defb $ff,0,0,0,0,0,0,0
0576 00 00 00 00 00 00 00 00 1025         defb $0,0,0,0,0,0,0,0
057e ff 00 00 00 00 00 00 00 1026 Block4: defb $ff,0,0,0,0,0,0,0
0586 00 00 00 00 00 00 00 00 1027         defb $0,0,0,0,0,0,0,0
058e ff 00 00 00 00 00 00 00 1028 Block5: defb $ff,0,0,0,0,0,0,0
0596 00 00 00 00 00 00 00 00 1029         defb $0,0,0,0,0,0,0,0
059e ff 00 00 00 00 00 00 00 1030 Block6: defb $ff,0,0,0,0,0,0,0
05a6 00 00 00 00 00 00 00 00 1031         defb $0,0,0,0,0,0,0,0
05ae ff 00 00 00 00 00 00 00 1032 Block7: defb $ff,0,0,0,0,0,0,0
05b6 00 00 00 00 00 00 00 00 1033         defb $0,0,0,0,0,0,0,0
05be ff 00 00 00 00 00 00 00 1034 Block8: defb $ff,0,0,0,0,0,0,0
05c6 00 00 00 00 00 00 00 00 1035         defb $0,0,0,0,0,0,0,0
05ce ff 00 00 00 00 00 00 00 1036 Block9: defb $ff,0,0,0,0,0,0,0
05d6 00 00 00 00 00 00 00 00 1037         defb $0,0,0,0,0,0,0,0
05de ff 00 00 00 00 00 00 00 1038 Block10: defb $ff,0,0,0,0,0,0,0
05e6 00 00 00 00 00 00 00 00 1039         defb $0,0,0,0,0,0,0,0
05ee ff 00 00 00 00 00 00 00 1040 Block11: defb $ff,0,0,0,0,0,0,0
05f6 00 00 00 00 00 00 00 00 1041         defb $0,0,0,0,0,0,0,0
05fe ff 00 00 00 00 00 00 00 1042 Block12: defb $ff,0,0,0,0,0,0,0
0606 00 00 00 00 00 00 00 00 1043         defb $0,0,0,0,0,0,0,0
060e ff 00 00 00 00 00 00 00 1044 Block13: defb $ff,0,0,0,0,0,0,0
0616 00 00 00 00 00 00 00 00 1045         defb $0,0,0,0,0,0,0,0
061e ff 00 00 00 00 00 00 00 1046 Block14: defb $ff,0,0,0,0,0,0,0
0626 00 00 00 00 00 00 00 00 1047         defb $0,0,0,0,0,0,0,0
062e ff 00 00 00 00 00 00 00 1048 Block15: defb $ff,0,0,0,0,0,0,0
0636 00 00 00 00 00 00 00 00 1049         defb $0,0,0,0,0,0,0,0
063e             1050 
063e 00 00       1051 DBWORK: defb 0,0
0640             1052 
0640             1053 DATABLOCK:
0640             1054 ;;;;;;;;;;;;
0640             1055 ;
0640 d5          1056       push de 
0641 23          1057         inc hl                  ; +6
0642 7c          1058         ld a,h                  ; +4
0643 e6 80       1059         and $80                 ; +7
0645 cc 19 07    1060         call z,BANKUP ; this also sets HL to 8000 +17/10
0648 7e          1061         ld a,(hl) 
0649             1062         ; find an empty block of pointers
0649 e5          1063         push hl ;9f43 = 66
064a 21 2e 05    1064          ld hl,DataType-16
064d 01 10 00    1065          ld bc,16      ; 16 BYTES IN SIZE 
0650             1066 _blockfind:
0650 af          1067          xor a 
0651 ed 4a       1068          adc hl,bc 
0653 7e          1069          ld a,(hl)    ; hl += 16
0654 fe ff       1070          cp $ff 
0656 28 02       1071          jr z,_blockok 
0658 18 f6       1072          jr _blockfind 
065a             1073 _blockok:         
065a e5          1074          push hl 
065b c1          1075          pop bc ; now BC has block struct pointer. 
065c ed 43 3e 06 1076          LD (DBWORK),BC 
0660 e1          1077         pop hl                  
0661             1078 
0661 23          1079         inc hl                  ; +6
0662 7c          1080         ld a,h                  ; +4
0663 e6 80       1081         and $80                 ; +7
0665 cc 19 07    1082         call z,BANKUP ; this also sets HL to 8000 +17/10
0668 7e          1083         ld a,(hl) 
0669 02          1084         ld (bc),a  ; data type  ; = 0
066a 23          1085         inc hl                  ; +6
066b 7c          1086         ld a,h                  ; +4
066c e6 80       1087         and $80                 ; +7
066e cc 19 07    1088         call z,BANKUP ; this also sets HL to 8000 +17/10
0671             1089         ; TODO: Check data type
0671             1090         
0671 03          1091         inc bc 
0672 7e          1092         ld a,(hl)  ; 9f45 = 77
0673 02          1093         ld (bc),a ; data size
0674 32 29 00    1094         ld (WORKRAM),a 
0677 23          1095         inc hl                  ; +6
0678 7c          1096         ld a,h                  ; +4
0679 e6 80       1097         and $80                 ; +7
067b cc 19 07    1098         call z,BANKUP ; this also sets HL to 8000 +17/10
067e             1099         
067e 7e          1100         ld a,(hl)
067f 03          1101         inc bc  
0680 02          1102         ld (bc),a ; data size+1 = 0c
0681 32 2a 00    1103         ld (WORKRAM+1),a ; for later
0684 23          1104         inc hl                  ; +6
0685 7c          1105         ld a,h                  ; +4
0686 e6 80       1106         and $80                 ; +7
0688 cc 19 07    1107         call z,BANKUP ; this also sets HL to 8000 +17/10
068b             1108         
068b 03          1109         inc bc 
068c 7e          1110         ld a,(hl) 
068d 02          1111         ld (bc),a ; data size+2 = 00
068e 32 2b 00    1112         ld (WORKRAM+2),a 
0691 23          1113         inc hl                  ; +6
0692 7c          1114         ld a,h                  ; +4
0693 e6 80       1115         and $80                 ; +7
0695 cc 19 07    1116         call z,BANKUP ; this also sets HL to 8000 +17/10
0698             1117         
0698 03          1118         inc bc 
0699 7e          1119         ld a,(hl) 
069a 02          1120         ld (bc),a ; data size+3 = 00
069b 32 2c 00    1121         ld (WORKRAM+3),a 
069e             1122         
069e             1123         ; now store HL, which is right before data start...
069e 03          1124         inc bc 
069f 7d          1125         ld a,l   ; dataloc l...
06a0 02          1126         ld (bc),a 
06a1             1127         
06a1 7c          1128         ld a,h   ; and h
06a2 03          1129         inc bc 
06a3 02          1130         ld (bc),a ;
06a4             1131         
06a4 3a 06 01    1132         ld a,(RomBank) 
06a7 03          1133         inc bc     ; DataBank
06a8 02          1134         ld (bc),a ; and store current rom bank, cuz this must be where it starts
06a9 32 1f 02    1135         ld (ZadrWork),a 
06ac af          1136         xor a 
06ad 32 20 02    1137         ld (ZadrWork+1),a 
06b0 22 21 02    1138         ld (ZadrWork+2),hl ; 0, 0, 9a9f ( = 1a9f)
06b3             1139 ;Counter 4 (32bit offset remaining to play of this loop)
06b3 2a 29 00    1140         ld hl,(WORKRAM) 
06b6 7d          1141         ld a,l 
06b7 03          1142         inc bc     ; ctr+0
06b8 02          1143         ld (bc),a 
06b9 7c          1144         ld a,h 
06ba 03          1145         inc bc 
06bb 02          1146         ld (bc),a  ; ctr+1 
06bc 2a 2b 00    1147         ld hl,(WORKRAM+2) 
06bf 7d          1148         ld a,l 
06c0 03          1149         inc bc   ; ctr+2
06c1 02          1150         ld (bc),a 
06c2 7c          1151         ld a,h 
06c3 03          1152         inc bc 
06c4 02          1153         ld (bc),a  ; ctr+3 
06c5             1154         ; BlockActive starts at 0, we set it to 1 when we hit FASTCALL. 
06c5             1155         ; so ignore the rest.
06c5             1156 
06c5             1157         ; NEW FUNCTION: Get 68000 address from current bank/HL
06c5 cd 5f 02    1158         call GETROMADDRESS
06c8             1159         ; ZadrWork = 32bit address of data bank start 
06c8             1160         ; WORKRAM = data size 
06c8             1161         ; add WORKRAM to ZadrWork
06c8 2a 1f 02    1162         ld hl,(ZadrWork) ; 
06cb ed 4b 29 00 1163         ld bc,(WORKRAM)  ; data size low 16 
06cf b7          1164         or a 
06d0 ed 4a       1165         adc hl,bc ; check carry 
06d2 22 1f 02    1166         ld (ZadrWork),hl ; save low 16
06d5 2a 21 02    1167         ld hl,(ZadrWork+2) 
06d8 01 00 00    1168         ld bc,$0000
06db ed 4a       1169         adc hl,bc  ; ok  ; carry is cleared here)
06dd ed 4b 2b 00 1170         ld bc,(WORKRAM+2) 
06e1 ed 4a       1171         adc hl,bc  ; upper 16
06e3 22 21 02    1172         ld (ZadrWork+2),hl 
06e6 cd 23 02    1173         call SETZADDRESS  ; s
06e9             1174         ; now our song pointer and rom window should be
06e9             1175         ; at the byte following the data block -1.
06e9 d1          1176      pop de 
06ea             1177 _compressed: ; TODO do extra stuff for compressed data
06ea             1178 _uncompressed:
06ea c3 a5 01    1179         jp PLAYLOOP     
06ed             1180 
06ed             1181 _emptyblock
06ed 3e ff       1182         LD A,$FF 
06ef e5          1183         PUSH HL 
06f0 2a 3e 06    1184         LD HL,(DBWORK) 
06f3 77          1185         LD (HL),A 
06f4 e1          1186         POP HL 
06f5 d1          1187         POP DE 
06f6 c3 a5 01    1188         JP PLAYLOOP 
06f9             1189 
06f9             1190 BANKSWAP:
06f9             1191 ;;;;;;;;;;;;;
06f9             1192 ; * A (preserve bc)
06f9             1193 ; RomBank has the # of the 32kb block to write to 6001.
06f9             1194 ;  Keep it 8 bits for now FIXME for > 8MB song locations 
06f9 c5          1195         push bc                         ; +11
06fa 0e 01       1196         ld c, 1         ; = 0b00000001  ; +7
06fc b7          1197         or a                            ; +4
06fd             1198 _bswp2: 
06fd 3a 06 01    1199         ld a,(RomBank)                  ; +13
0700 a1          1200         and c                           ; +4
0701 fe 00       1201         cp 0                            ; +7
0703 28 02       1202         jr z,_bzero                     ; +12/+7
0705 18 03       1203         jr _bone                        ; +12
0707             1204 _bzero: 
0707             1205         ;call ZWAIT 
0707 af          1206         xor a                           ; +4
0708 18 02       1207         jr _bwrt                        ; +12
070a             1208 _bone:
070a             1209         ;call ZWAIT 
070a 3e 01       1210         ld a,1                          ; +7
070c             1211 _bwrt:
070c 32 01 60    1212         ld ($6001),a                    ; +13
070f cb 21       1213         sla c           ; = 0b00000010  ; +8
0711 30 ea       1214         jr nc,_bswp2    ; loop until bit goes into carry; +12/+7
0713             1215 
0713             1216         ;call ZWAIT 
0713 af          1217         xor a                   ; +4
0714 32 01 60    1218         ld ($6001),a       ; 9 bit = 0 ( works for < 8MB); +13
0717 c1          1219         pop bc                          ; +10
0718 c9          1220         ret                             ; +10
0719             1221 ;;;;                                    ; ~300?
0719             1222 
0719             1223 BANKUP:
0719             1224 ;;;;;;;;;;;;;;
0719             1225 ; * A H L
0719             1226 ; Pops up the rom bank by 1 and 
0719             1227 ; sets HL back to $8000
0719 3a 06 01    1228         ld a,(RomBank)          ; +13
071c 3c          1229         inc a                   ; +4   
071d 32 06 01    1230         ld (RomBank),a          ; +13
0720 cd f9 06    1231         call BANKSWAP           ; +17 +(BANKSWAP)
0723 21 00 80    1232         ld hl,$8000             ; +10
0726 c9          1233         ret                     ; +10
0727             1234 ;;;;                            ; Total : 67+~300
0727             1235 
0727             1236 
0727             1237 WRITEFM1:
0727             1238 ;;;;;;;;;;;;;;;;;;;
0727             1239 ; HL - location of song byte
0727             1240 ; * A  
0727 23          1241         inc hl                  ; +6
0728 7c          1242         ld a,h                  ; +4
0729 e6 80       1243         and $80                 ; +7
072b cc 19 07    1244         call z,BANKUP ; this also sets HL to 8000 +17/10
072e 3a 00 40    1245         LD A,($4000) 
0731 87          1246         ADD A, A 
0732 38 fc       1247         JR C,-4
0734 7e          1248         LD A,(HL) 
0735 32 00 40    1249         LD (FMREG0),A
0738 23          1250         inc hl                  ; +6
0739 7c          1251         ld a,h                  ; +4
073a e6 80       1252         and $80                 ; +7
073c cc 19 07    1253         call z,BANKUP ; this also sets HL to 8000 +17/10
073f 3a 00 40    1254         LD A,($4000) 
0742 87          1255         ADD A, A 
0743 38 fc       1256         JR C,-4
0745 7e          1257         LD A,(HL) 
0746 32 01 40    1258         LD (FMDAT0),A 
0749 c3 a5 01    1259         JP PLAYLOOP
074c             1260 ;;;;
074c             1261 
074c             1262 ZWAIT:
074c             1263 ;;;;;;;;;;;;;;;;;;
074c             1264 ; * A C
074c 3a 00 40    1265         LD A,($4000) 
074f 87          1266         ADD A, A 
0750 38 fc       1267         JR C,-4
0752 c9          1268         RET 
0753             1269 ;;;;
0753             1270 
0753             1271 
0753             1272 
0753             1273 
0753             1274 WRITEFM2:
0753             1275 ;;;;;;;;;;;;;;;;
0753             1276 ; HL = song byte
0753             1277 ; * A
0753 23          1278         inc hl                  ; +6
0754 7c          1279         ld a,h                  ; +4
0755 e6 80       1280         and $80                 ; +7
0757 cc 19 07    1281         call z,BANKUP ; this also sets HL to 8000 +17/10
075a 3a 00 40    1282         LD A,($4000) 
075d 87          1283         ADD A, A 
075e 38 fc       1284         JR C,-4
0760 7e          1285         LD A,(HL) 
0761 32 02 40    1286         LD (FMREG1),A 
0764 23          1287         inc hl                  ; +6
0765 7c          1288         ld a,h                  ; +4
0766 e6 80       1289         and $80                 ; +7
0768 cc 19 07    1290         call z,BANKUP ; this also sets HL to 8000 +17/10
076b 3a 00 40    1291         LD A,($4000) 
076e 87          1292         ADD A, A 
076f 38 fc       1293         JR C,-4
0771 7e          1294         LD A,(HL) 
0772 32 03 40    1295         LD (FMDAT1),A 
0775 c3 a5 01    1296         JP PLAYLOOP 
0778             1297 ;;;;
0778             1298 
0778             1299 WRITEPSG:
0778             1300 ;;;;;;;;;;;;;;;;
0778             1301 ; HL = song byte 
0778             1302 ; * A
0778 23          1303         inc hl                  ; +6
0779 7c          1304         ld a,h                  ; +4
077a e6 80       1305         and $80                 ; +7
077c cc 19 07    1306         call z,BANKUP ; this also sets HL to 8000 +17/10
077f             1307         ;CALL ZWAIT 
077f 7e          1308         LD A,(HL) 
0780 32 11 7f    1309         ld (PSGREG),a 
0783 c3 a5 01    1310         JP PLAYLOOP 
0786             1311 ;;;;
0786             1312 
0786             1313 
0786             1314 
0786             1315 SAMPLEWAIT:
0786             1316 ;;;;;;;;;;;
0786             1317 ; * A, B, C
0786             1318 ; HL = song byte
0786 23          1319         inc hl                  ; +6
0787 7c          1320         ld a,h                  ; +4
0788 e6 80       1321         and $80                 ; +7
078a cc 19 07    1322         call z,BANKUP ; this also sets HL to 8000 +17/10
078d 7e          1323         LD A,(HL)
078e 4f          1324         LD C,A  
078f 23          1325         inc hl                  ; +6
0790 7c          1326         ld a,h                  ; +4
0791 e6 80       1327         and $80                 ; +7
0793 cc 19 07    1328         call z,BANKUP ; this also sets HL to 8000 +17/10
0796 7e          1329         LD A,(HL)
0797 47          1330         LD B,A          ; BC = SAMPLE WAIT 16BIT
0798             1331 _sw2 
0798             1332         ;call DACBLOCKTRANSFER
0798             1333 _sampwt:        
0798 3a 00 01    1334         LD A,(PlayNext)  ; check the 'play next frame' var
079b fe 00       1335         CP 0             ; is it = 1?
079d 28 f9       1336         JR Z,_sampwt    ; if not, wait until frame is over
079f             1337         ;call DACBLOCKTRANSFER
079f af          1338         xor a
07a0 32 00 01    1339         ld (PlayNext),a  ; clear play var
07a3             1340         ; subtract 735 from BC 
07a3 e5          1341         push hl         ; save song pointer
07a4 c5          1342           push bc       ; sample wait value:
07a5 e1          1343           pop hl        ; bc to hl 
07a6 3a 08 01    1344          ld a,(PALFlag) 
07a9 fe 01       1345          cp 1 
07ab 20 05       1346          jr nz,_palsize
07ad             1347          ;push hl 
07ad             1348          ; ld hl,267  ;735
07ad             1349          ; ld bc,(DacFrequency) 
07ad             1350          ; sbc hl,bc 
07ad             1351          ; push hl 
07ad             1352          ; pop bc 
07ad             1353          ;pop hl ;  bc = 735-dacfreq
07ad 01 df 02    1354          ld bc,735     ;  267
07b0 18 03       1355          jr __3
07b2             1356 _palsize 
07b2 01 72 03    1357          ld bc,882      ; PAL
07b5             1358 __3 
07b5 ed 42       1359          sbc hl,bc      ; samplewait - 735 -> HL
07b7 e5          1360          push hl 
07b8 c1          1361          pop bc         ; store it back in bc 
07b9 e1          1362         pop hl          ; recover song pointer
07ba 30 dc       1363         jr nc,_sw2   ; wait another frame if samplewait is still > 0
07bc             1364 
07bc c3 a5 01    1365         JP PLAYLOOP 
07bf             1366 ;;;;
07bf             1367 
07bf             1368 
07bf             1369 CLEARPSG:
07bf             1370 ;;;;;;;;;;;;;;;;;;;;
07bf             1371 ; clear the SSG (mute)
07bf             1372 ; * A, B (preserve HL)
07bf e5          1373         push hl 
07c0 21 20 00    1374         LD HL,CLRTB 
07c3 06 04       1375         ld b,4
07c5             1376 _clearlp:
07c5 7e          1377         ld a,(hl) 
07c6 32 11 7f    1378         ld (PSGREG),a 
07c9 23          1379         inc hl                  ; +6
07ca 7c          1380         ld a,h                  ; +4
07cb e6 80       1381         and $80                 ; +7
07cd cc 19 07    1382         call z,BANKUP ; this also sets HL to 8000 +17/10
07d0 10 f3       1383         djnz _clearlp
07d2 e1          1384         pop hl 
07d3 c9          1385         RET
07d4             1386 ;;;;
07d4             1387 
07d4             1388 
07d4             1389 
1939 bytes code generated and 150 labels defined
