0000                1 ;;;;;;;;;;;;;;;;;
0000                2 ;;
0000                3 ;; Z80 VGM Player
0000                4 ;; 
0000                5 ; (c) Ben Ferguson 2021
0000                6 
0000                7 ;;; TO USE: 
0000                8 ; Set byte a00080 to 1 every vblank to play!
0000                9 ; read byte a00081 to see if song is playing or not.
0000               10 ; Set SongBaseAddress (82h-85h) to full 32bit address 
0000               11 ; and RomBank (86h) to bit 15+ of the 68000 memory bank
0000               12 ; If PAL, set the PAL flag to 1 (88h), otherwise, 0=NTSC
0000               13 
0000               14 ; TODOS:
0000               15 ; - Tie z80 to vblank interrupt so it isn't driven by 68000
0000               16 ; - Add error checking for vgm 1.60
0000               17 ; - weirder bytecodes 
0000               18 ; - multiple sample streams 
0000               19 ; - WIP: multiple data blocks
0000               20 
0000               21 ;;;;;
0000               22 ; FIXMEs
0000               23 ; data banks need to be initialized properly
0000               24 ; copy and paste CurDac stuff within dac loop 
0000               25 
0000               26 FMREG0 EQU $4000
0000               27 FMDAT0 EQU $4001
0000               28 FMREG1 EQU $4002
0000               29 FMDAT1 EQU $4003
0000               30 BANKREG EQU $6000
0000               31 PSGREG EQU $7F11
0000               32 
0000               33 
0000               34 VGM_START EQU $00 
0000               35 VGM_END EQU $04       ;*: ; 2004-2005
0000               36 SSGCLOCK EQU $0C      ; : ; 200c-200f
0000               37 SAMPLECOUNT EQU $18   ;*:  ; 2018-201b 0X22740
0000               38 LOOPOFFSET EQU $1c    ;*: 201c-201f
0000               39 LOOPNUMS EQU $20      ;*:   ; 2020-2023
0000               40 RATE EQU $24          ;:   ; 2024-2027 = 60
0000               41 SNFB EQU $28          ;*?:  ; 2028-9 = 0009
0000               42 SNW EQU $2a           ;*?; 202a = 16
0000               43 SF EQU $2b            ;*:    ; 202b ; ssg flags all 0
0000               44 YM2612CLK EQU $2C     ;: ; 202c-202f = 0x750ab6 
0000               45 VGMDATOFS EQU $34     ;*:  ; 2034-2037
0000               46 ;SPCMCLK EQU $2038       ;:    ; 2038-203b
0000               47 ;SPCMI EQU $203C         ;:   ; 203c-203f
0000               48 VM EQU $7C            ;: volume modifier (default 0) ; 207c
0000               49 LB EQU $7E            ;: loop base; 207e
0000               50 LM EQU $7F            ;: loop modifier; 207f
0000               51         
0000               52         org $0
0000               53 
0000               54 ; disable interrupts
0000 f3            55         di 
0001               56 
0001               57 ; clear the stack
0001 3e 00         58         ld a, 0
0003 11 00 1c      59         ld de, $1c00 
0006 06 00         60         ld b, 0 
0008               61 _clrstack:
0008 12            62         LD (DE),A
0009 13            63         inc de 
000a 10 fc         64         djnz _clrstack
000c               65 _clr2
000c 12            66         ld (de),a 
000d 13            67         inc de 
000e 10 fc         68         djnz _clr2
0010               69 _clr3 
0010 12            70         ld (de),a 
0011 13            71         inc de 
0012 10 fc         72         djnz _clr3
0014               73 
0014               74 ; set the stack pointer 
0014 31 80 1d      75         ld sp,$1d80 
0017               76 
0017               77 ; clear and go!
0017 cd d2 06      78         call CLEARPSG 
001a cd 25 06      79         call BANKSWAP
001d               80 
001d c3 8a 00      81         jp LOADVGM 
0020               82         
0020               83 ; +8 and +9 should contain VGM version number.
0020               84 ;VERSIONCHECK:
0020               85 ;        ld hl, ($2008) 
0020               86 ;        cp h, $60
0020               87 ;        jr nz,WRONGVER
0020               88 ;        cp l, $01
0020               89 ;        jr nz,WRONGVER 
0020               90 ;        jp LOADVGM
0020               91 ;WRONGVER:
0020               92 ;        jp WRONGVER
0020               93 
0020               94 CLRTB:
0020 9f bf df ff   95         defb $9f,$bf,$df,$ff
0024               96 LoopPlay: 
0024 00            97         defb 0
0025               98 LoopLoc:        
0025 00 00 00 00   99         defb 0,0,0,0
0029              100 
0029 00 00 00 00  101 WORKRAM: defb 0,0,0,0
002d              102 
002d 00 00 00 00  103 SongDataStart: defb 0,0,0,0
0031              104 
0031              105 
0031              106 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031              107 
0031              108         org $80
0080              109 
0080              110 ; Vars
0080              111 
0080              112 PlayNext:
0080 00           113         defb 0          ; 80h
0081              114 SongPlaying: 
0081 00           115         defb 0          ; 81h
0082              116 SongBaseAddress:        ; Set me when loading the song from the 68000!
0082 00 00 00 00  117         defb $0, $0, 0, 0 ; 82-85h
0086              118 RomBank:
0086 00           119         defb 0          ; 86h
0087              120 StartBank:
0087 00           121         defb 0          ; --
0088              122 ; This is 0 if NTSC, and 1 if PAL.
0088 00           123 PALFlag: defb 0         ; 88h
0089              124 ; Set this to 1 and the next frame the Z80 will reset (jp 0). 
0089              125 ; Do this after changing SongBaseAddress to change songs. 
0089 00           126 ResetFlag: defb 0       ; 89h
008a              127  
008a              128 
008a              129 LOADVGM:
008a              130 ;;;;;;;;;;;;;;;;
008a              131         
008a 3e 01        132         LD A,1 
008c 32 81 00     133         LD (SongPlaying),A      ; set playing var to ON
008f 3a 86 00     134         LD A,(RomBank) 
0092 32 87 00     135         LD (StartBank),A        ; Store the initial ROM bank for looping.
0095              136         
0095              137 ; Set the memory window to the song header (+1c)      
0095 2a 82 00     138         ld hl,(SongBaseAddress)
0098 01 1c 00     139         ld bc,$001c 
009b af           140         xor a 
009c ed 4a        141         adc hl,bc 
009e 22 dd 01     142         ld (ZadrWork),hl 
00a1 2a 84 00     143         ld hl,(SongBaseAddress+2)
00a4 01 00 00     144         ld bc,$0000
00a7 ed 4a        145         adc hl,bc               ; catch the carry
00a9 22 df 01     146         ld (ZadrWork+2),hl
00ac cd e1 01     147         call SETZADDRESS        ; set bank to song base address + 1c!
00af              148 
00af              149 ; Is the loop variable = 00 00 ?
00af 7e           150         ld a,(hl)               ; pointer is at loop portion of header. 
00b0 4f           151         ld c,a 
00b1 cd bc 01     152         call GetNextSongByte    ; HL++
00b4 7e           153         ld a,(hl)               ; Is there loop location?
00b5 b1           154         or c  
00b6 28 43        155         jr z, noloop            ; checks first two bytes only~~~
00b8 7e           156         ld a,(hl)
00b9 47           157         ld b,a                  ; 1c and 1d are in bc
00ba              158 ; store the 32bit 68000 address at LoopLoc
00ba e5           159         push hl 
00bb c5           160          push bc 
00bc e1           161          pop hl 
00bd 22 25 00     162          ld (LoopLoc),hl ; store 1c-1d here
00c0 e1           163         pop hl          ; at LoopLoc
00c1 cd bc 01     164         call GetNextSongByte 
00c4 7e           165         ld a,(hl) 
00c5 4f           166         ld c,a 
00c6 cd bc 01     167         CALL GetNextSongByte
00c9 7e           168         ld a,(hl) 
00ca 47           169         ld b,a 
00cb c5           170         push bc         ; excg
00cc e1           171         pop hl          ; bc and hl
00cd 22 27 00     172         ld (LoopLoc+2),hl  ; and at LoopLoc+2
00d0              173         ; WE AREN'T DONE!!!
00d0              174 ; we need to convert this to the 68000 range.;
00d0 2a 82 00     175         ld hl,(SongBaseAddress) 
00d3 e5           176         push hl 
00d4 c1           177         pop bc                  ; HL = LoopLoc+0, BC=SongBaseAddress+0 
00d5 2a 25 00     178         ld hl,(LoopLoc) 
00d8 af           179         xor a 
00d9 ed 4a        180         adc hl,bc               ; if it overflows, its in the carry...
00db 22 25 00     181         ld (LoopLoc),hl         ; lower byte stored
00de 2a 27 00     182         ld hl,(LoopLoc+2)       ; load upper byte and store carry
00e1 01 00 00     183         ld bc,$0000
00e4 ed 4a        184         adc hl,bc               ; <- carry taken care of. 
00e6 22 27 00     185         ld (LoopLoc+2),hl 
00e9              186         ; HL = LoopLoc+2 and carry
00e9 e5           187         push hl 
00ea 2a 84 00     188          ld hl,(SongBaseAddress+2) 
00ed e5           189          push hl 
00ee c1           190          pop bc 
00ef e1           191         pop hl    ; HL = LoopLoc+2+c, BC = SongBaseAddress+2
00f0 af           192         xor a     ; clear carry for the upper bytes 
00f1 ed 4a        193         adc hl,bc               ; phew! NOW we're good 
00f3 22 27 00     194         ld (LoopLoc+2),hl 
00f6              195 ; Set start playing flag 
00f6 3e 01        196         ld a,1 
00f8 32 24 00     197         ld (LoopPlay),a           ; set LoopPlay to 1
00fb              198 noloop:
00fb              199 ; Now set HL to song data pointer - longword at 0x0034 into the VGM header 
00fb 2a 82 00     200         ld hl,(SongBaseAddress)    ; 00001ef7, need to add 83 to skip header and
00fe              201                                    ; byte size
00fe 01 80 00     202         ld bc, $0080      ; skip the header
0101 af           203         xor a 
0102 ed 4a        204         adc hl,bc  ; 0x100              ; 1f2b 1f2e is wrong! should be 1f7a
0104 22 dd 01     205         ld (ZadrWork),hl           ; 16bit addition ; START BAD CODE
0107 01 00 00     206         ld bc,$0000
010a 2a 84 00     207         ld hl,(SongBaseAddress+2)
010d ed 4a        208         adc hl,bc ; catch the carry 
010f 22 df 01     209         ld (ZadrWork+2),hl              ; < ok
0112 cd e1 01     210         call SETZADDRESS   
0115              211 ; TODO FIXME i am not reading addr from header right now     
0115              212 ; This means only 128-byte header VGMs (1.60 will work!)
0115              213         ; hl now contains base+34 or data offset start
0115              214 ; Get the 68000 address and store it in SongDataStart (our sram var) 
0115 7e           215         ld a,(hl) ; data start offset bits 0-7. add this to ;
0116              216 
0116 2b           217         dec hl  ;) < go down one because we call GetNextSongByte below
0117              218 PLAYLOOP:
0117              219 ;;;;;;;;;;;;;;;;
0117 cd bc 01     220         call GetNextSongByte
011a 7e           221         LD A,(HL) 
011b fe 50        222         cp $50 
011d da 8f 01     223          jp c,ERROR      ; 0-49f - ERROR, invalid control byte
0120 ca 91 06     224         JP z,WRITEPSG   ; 50f - write PSG
0123 fe 52        225         cp $52          ; 0x52 a b - 2612 port 0 (gen FM1) <-
0125 ca 5c 06     226         JP z,WRITEFM1
0128 fe 53        227         cp $53          ; 0x53 a b - 2612 port 1 (gen FM2) <-
012a ca 7a 06     228         JP z,WRITEFM2
012d fe 61        229         CP $61          ; 0X61 a b - wait ba samples
012f ca 9e 06     230         JP Z,SAMPLEWAIT 
0132 fe 62        231         CP $62          ; 0x62 wait 1/60 second
0134 ca 7d 01     232         JP Z,FRAMEOVER  ; (until next vblank)
0137 fe 63        233         CP $63
0139 ca 7d 01     234         JP Z,FRAMEOVER  ; Same frame wait code won't make a difference on PAL
013c fe 66        235         CP $66          
013e da 8f 01     236          JP C,ERROR      ; 64-65 error 
0141 ca 99 01     237         JP Z,SONGOVER   ; 0x66 stop music playback
0144 fe 67        238         CP $67          ; DATA BLOCK 
0146 ca 96 05     239         JP Z,DATABLOCK  ;  sets up all pointers
0149 fe 68        240         cp $68 
014b ca c8 01     241         JP Z,WRITEPCM   ;  probably not used 
014e fe 7c        242         CP $7C
0150 28 72        243         JR Z,VOLUMESET    ; discrete volume control
0152 fe 80        244         CP $80
0154 da cc 01     245         JP C,QWAIT        ; 69-7f (not 7c) quick wait
0157 fe 90        246         CP $90 
0159 da da 01     247         JP C,QFMWAIT      ; 80-8f quick fm write/wait
015c ca 74 03     248         jp z,DACSETUP     ; 90 setup dac stream
015f fe 91        249         CP $91 
0161 ca 87 03     250         JP Z,SETDACSTREAM
0164 fe 92        251         CP $92 
0166 ca b8 03     252         JP Z,SETDACFREQ
0169 fe 93        253         CP $93 
016b ca 28 04     254         JP Z,STARTDACSTREAM ; UNSUPPORTED FIXME
016e fe 94        255         CP $94 
0170 ca 42 03     256         JP Z,STOPDAC
0173 fe 95        257         CP $95
0175 ca 4a 04     258         JP Z,DACFASTCALL
0178 fe ff        259         CP $FF 
017a da 8f 01     260          JP C,ERROR     ; 96-fe goto ERROR
017d              261         
017d              262 FRAMEOVER:
017d              263 ;;;;;;;;;;;
017d              264 ; * A
017d              265 ; Waits until next vblank signal (done via 68k)
017d              266         ;JP FRAMEOVER 
017d              267         ; Before checking 68k vbl, we need to see if DAC are queued.
017d              268         ;LD A,(DacTransferActive) 
017d              269         ;cp 0 
017d cd 53 02     270         call DACBLOCKTRANSFER ; MAD TESTING BRUH
0180              271 _framewait:
0180 3a 80 00     272         LD A,(PlayNext)  ; check the 'play next frame' var
0183 fe 01        273         CP 1             ; is it = 1?
0185 20 f9        274         JR NZ,_framewait  ; if not, loop.
0187 af           275         xor a            ; if it is, clear it.
0188 32 80 00     276         ld (PlayNext),a 
018b c3 17 01     277         JP PLAYLOOP
018e              278 ;;;; 
018e              279 
018e 99           280 ERRDEFB: DEFB $99
018f              281 ; This error handling is super rudimentary and only intended to get songs to
018f              282 ;  play without crashing!
018f              283 ERROR:  
018f              284         ;cp $28    ; probably just got lost 
018f              285         ;jr z,_fixsongptr
018f c3 8f 01     286         jp ERROR 
0192              287 
0192              288 _fixsongptr: 
0192 cd bc 01     289         call GetNextSongByte
0195 c3 17 01     290         jp PLAYLOOP 
0198              291 
0198 55           292 _songoverb: defb $55
0199              293 SONGOVER:
0199              294         
0199              295 ;;;;;;;;;;;
0199              296 ; * A
0199              297 ; Stops the song when hits command byte 0x66
0199              298 ;  Or, if looping, jumps to loop
0199 3a 24 00     299         ld a,(LoopPlay) 
019c fe 00        300         cp 0 
019e 28 12        301         jr z, _endsong  
01a0              302 ; LOOP PLAY:
01a0              303         ; LoopLoc should be all set...
01a0 2a 25 00     304         ld hl,(LoopLoc) 
01a3 22 dd 01     305         ld (ZadrWork),hl 
01a6 2a 27 00     306         ld hl,(LoopLoc+2) 
01a9 22 df 01     307         ld (ZadrWork+2),hl 
01ac cd e1 01     308         call SETZADDRESS 
01af c3 17 01     309         jp PLAYLOOP
01b2              310 _endsong:
01b2 af           311         XOR A 
01b3 32 81 00     312         LD (SongPlaying),A
01b6 cd d2 06     313         call CLEARPSG
01b9              314         ; TODO in case the VGM doesn't clear the FM stuff, do that here
01b9              315 _overloop
01b9 c3 b9 01     316         JP _overloop
01bc              317 
01bc              318 
01bc              319 GetNextSongByte:
01bc 23           320         inc hl 
01bd 7c           321         ld a,h 
01be e6 80        322         and $80 
01c0 cc 4e 06     323         call z,BANKUP ; this also sets HL to 8000
01c3 c9           324         ret 
01c4              325 
01c4              326 
01c4              327 VOLUMESET:
01c4              328         ;JP PLAYLOOP  
01c4 c3 c4 01     329         JP VOLUMESET 
01c7              330         
01c7              331 
01c7 11           332 aaa: defb $11
01c8              333 WRITEPCM:
01c8              334         ;jp PLAYLOOP  
01c8 c3 c8 01     335         JP WRITEPCM 
01cb 22           336 bbb: defb $22
01cc              337 ; Waits 1-16 samples
01cc              338 QWAIT:
01cc              339         ; TOO SHORT TO NOTICE?
01cc e6 0f        340         and $0f 
01ce 47           341         ld b,a 
01cf 0e 00        342         ld c,0 
01d1              343 _qwl:   ; idk what to do other than skip 256*n cycles
01d1 0b           344         dec bc 
01d2 79           345         ld a,c 
01d3 b0           346         or b 
01d4 20 fb        347         jr nz, _qwl
01d6              348         ;JP QWAIT 
01d6 c3 17 01     349         JP PLAYLOOP 
01d9 33           350 ccc: defb $33
01da              351 QFMWAIT:
01da              352         ;jp PLAYLOOP 
01da c3 da 01     353         JP QFMWAIT 
01dd              354 
01dd 00 00 00 00  355 ZadrWork: defb 0,0,0,0
01e1              356 
01e1              357 SETZADDRESS:
01e1              358 ;;;;;;;;;;;;;;;;;;
01e1              359 ; * A H L 
01e1              360 ; Input: ZadrWork 32-bit address (68000 memory)
01e1              361 ; Output: changes active rom bank, and sets HL to mem addr
01e1 2a de 01     362         ld hl,(ZadrWork+1) ; ignore bits 0-7, so we have 8-23
01e4 af           363         xor a ; clc 
01e5 cb 3c        364         srl h
01e7 cb 1d        365         rr l   ; hl >> 1
01e9 cb 3c        366         srl h
01eb cb 1d        367         rr l   ; hl >> 2
01ed cb 3c        368         srl h
01ef cb 1d        369         rr l   ; hl >> 3
01f1 cb 3c        370         srl h
01f3 cb 1d        371         rr l   ; hl >> 4
01f5 cb 3c        372         srl h
01f7 cb 1d        373         rr l   ; hl >> 5
01f9 cb 3c        374         srl h
01fb cb 1d        375         rr l   ; hl >> 6
01fd cb 3c        376         srl h
01ff cb 1d        377         rr l   ; hl >> 7 
0201 7d           378         ld a,l 
0202 32 86 00     379         ld (RomBank),a ; BITS 15-22
0205 cd 25 06     380         call BANKSWAP
0208 2a dd 01     381         LD HL,(ZadrWork)  ; 0-15 
020b 3e 7f        382         ld a,$7f 
020d a4           383         and h 
020e f6 80        384         or $80 ; always set top bit so we look at $8000 + 
0210 67           385         ld h,a
0211 e5           386         push hl 
0212 21 00 00     387         ld hl,$0000 
0215 22 dd 01     388         ld (ZadrWork),hl 
0218 22 df 01     389         ld (ZadrWork+2),hl 
021b e1           390         pop hl 
021c              391         ; [HL] now contains memory pointer!
021c c9           392         ret
021d              393 ;;;;
021d              394 
021d              395 GETROMADDRESS: 
021d              396 ;;;;;;;;;;;;;;
021d              397 ; INPUT: ZadrWork+0 BANK
021d              398 ;        ZadrWork+2~ZadrWork+3 HL
021d              399 ; (bank * 8000) + HL & 7fff
021d              400 ; OUTPUT: ZadrWork ~ ZadrWork+3 CONTAINS LONGWORD ADDRESS
021d              401 ; * A
021d              402 ; Preserves HL
021d e5           403         push hl
021e c5           404         push bc  
021f af           405          xor a ; clc 
0220 3a dd 01     406          ld a,(ZadrWork) ; contains RomBank, A15-A22
0223              407          ; 15:
0223 e6 01        408          and $1 
0225 cb 1f        409          rr a   ; 15 > carry 
0227 cb 1f        410          rr a   ; carry > 7, carry = 0
0229 47           411          ld b,a ; contains bit 15 ; SAVE
022a 3a dd 01     412          ld a,(ZadrWork) ; 15-22...
022d e6 fe        413          and $fe
022f cb 3f        414          srl a    ; and the last bit and shift RIGHT, so we have 16-23 (minus23)
0231 2a df 01     415          ld hl,(ZadrWork+2) 
0234 32 df 01     416          ld (ZadrWork+2),a ; put it in the 3rd byte 
0237 af           417          xor a 
0238 32 dd 01     418          ld (ZadrWork),a 
023b 32 de 01     419          ld (ZadrWork+1),a ; zero the first two
023e              420          
023e 3e 7f        421          ld a,$7f 
0240 a4           422          and h ; hl = bits 0-14, dont forget 15 in b!
0241 b0           423          or b           ; d(>.< )
0242 67           424          ld h,a
0243 22 dd 01     425          ld (ZadrWork),hl 
0246 af           426          xor a 
0247 32 e0 01     427          ld (ZadrWork+3),a ; 24-31 are always 0
024a c1           428         pop bc 
024b e1           429         pop hl 
024c c9           430         RET 
024d              431 
024d 00 00        432 DacWRAM: defb 0, 0
024f              433 DACWORK
024f 00 00 00 00  434         defb 0,0,0,0
0253              435 ; Block struct:
0253              436 ;Type (ff means empty) 1
0253              437 ; Compatible types:
0253              438 ; 0: YM2612 PCM data 
0253              439 ;Size 4
0253              440 ; 32 bit size (from VGM file)
0253              441 ;Loc 2 (HL offset of data start)
0253              442 ;Bank 1 (bank of data start)
0253              443 ;Counter 4 (32bit offset remaining to play of this loop)
0253              444 ;BlockActive: 1 if we need to dac stream it, 0 skips
0253              445 ;_buffer 3 : to align to 16 bytes
0253              446 
0253              447 DACBLOCKTRANSFER:
0253 c9           448         ret 
0254 c3 54 02     449 BREAKPOINT: JP BREAKPOINT 
0257              450 ;; Step through me again
0257              451         ; PRESERVE CURRENT ROM BANK AND SONG PTR IN WORKRAM~+3
0257 3a 86 00     452         ld a,(RomBank)          
025a 32 4f 02     453         ld (DACWORK),a 
025d af           454         xor a
025e 32 50 02     455         ld (DACWORK+1),a     ; saving me for later!
0261 22 51 02     456         ld (DACWORK+2),hl       
0264              457         ; LOOP THROUGH DATA STRUCT[], SEARCH FOR ACTIVE BYTE == 1
0264              458 ;        ld hl,BlockActive-16
0264              459 ;        ld b,16   ; 16 data arrays
0264              460 ;        ld de,1  ; 16 bytes each FIXME
0264              461 ;_nextdb
0264              462 ;        OR A 
0264              463 ;        adc hl,de 
0264              464 ;        ld a,(hl) 
0264              465 ;        cp $0
0264              466 ;        jr nz,_found
0264              467 ;        djnz _nextdb
0264              468 ;        cp $0 
0264              469 ;        jp z,_daclpend     ; if all are 0, return
0264              470 _found
0264              471         ; TESTING 
0264 3a a2 04     472         ld a,(BlockActive) 
0267 fe 00        473         cp 0 
0269 c8           474         ret z 
026a              475         ; b = 15 to 0 (to flip: 15 - b)
026a 21 0f 00     476         ld hl,15 
026d 0e 00        477         ld c,0
026f b7           478         or a 
0270 ed 42        479         sbc hl,bc 
0272 7d           480         ld a,l
0273              481         ; now [A] has active data bank 0-15
0273              482         ; TODO 
0273              483         ; GET THE STRUCT'S CTR, STORE IT IN ACTIVEDACCTR
0273              484 
0273              485         ; switch to ActiveDacBank|ActiveDacLoc 
0273 3a 48 04     486         ld a,(ActiveDacBank)     ; = 0
0276 32 86 00     487         ld (RomBank),a 
0279 cd 25 06     488         call BANKSWAP 
027c              489         ; output 267 bytes from the bank (TODO DacFrequency)
027c              490         ; 1. CHECK ACTIVEDACCTR+2~3 - IF > 0, BC = $10B
027c              491         ; 2. COMPARE ADC+0~1 WITH $10B - IF >, BC=$10B
027c              492         ;    ELSE BC = ADC+0~1
027c              493         ; STORE BC IN DACWRAM
027c              494         
027c cd 73 06     495         CALL ZWAIT 
027f 3e 2b        496         ld a,$2b 
0281 32 00 40     497         ld ($4000),a 
0284 cd 73 06     498         CALL ZWAIT 
0287 3e 80        499         ld a,$80 
0289 32 01 40     500         ld ($4001),a 
028c              501 
028c 2a 44 04     502         LD HL,(ActiveDacCtr+2) 
028f 7c           503         LD A,H 
0290 b5           504         or L 
0291 20 1a        505         JR NZ,_norm   ; if either of the two high bytes are > 0, normal.
0293              506         
0293 ed 4b 42 04  507         ld bc,(ActiveDacCtr) 
0297 3a 9e 03     508         ld a,(DacFrequency)
029a 91           509         sub c 
029b 3a 9f 03     510         ld a,(DacFrequency+1)
029e 98           511         sbc a,b 
029f 38 0c        512         jr c,_norm 
02a1              513         ; else, short dac 
02a1 ed 4b 42 04  514         ld bc,(ActiveDacCtr) 
02a5 79           515         ld a,c 
02a6 b0           516         or b
02a7 ca f5 02     517         jp z,_enddac
02aa c3 b1 02     518         jp _nr
02ad              519 _norm:
02ad ed 4b 9e 03  520         ld bc,(DacFrequency) ;; (DacFrequency) ; hopefully 267: debug me
02b1              521 _nr:
02b1 ed 43 4d 02  522         ld (DacWRAM),bc 
02b5 2a 46 04     523         ld hl,(ActiveDacLoc) ; already -1!
02b8              524 dacwriteloop:
02b8              525         ;call ZWAIT 
02b8 3e 2a        526         ld a,$2a
02ba 32 00 40     527         ld ($4000),a
02bd cd bc 01     528         call GetNextSongByte
02c0              529         ;call ZWAIT  
02c0 7e           530         ld a,(hl)
02c1 32 01 40     531         ld ($4001),a 
02c4              532         
02c4 3a 86 00     533         ld a,(RomBank) 
02c7 32 48 04     534         ld (ActiveDacBank),a ; may be unnecessary 
02ca 22 46 04     535         ld (ActiveDacLoc),hl 
02cd 0b           536         dec bc
02ce 79           537         ld a,c 
02cf b0           538         or b 
02d0 20 e6        539         jr nz,dacwriteloop 
02d2              540         ; 3. SUBTRACT DACWRAM FROM ADC (32BIT-16BIT)
02d2 b7           541         or a ; clc 
02d3 e5           542         push hl 
02d4 c5           543          push bc 
02d5 2a 42 04     544           ld hl,(ActiveDacCtr) 
02d8 ed 4b 4d 02  545           ld bc,(DacWRAM) 
02dc b7           546           or a  ; clc 
02dd ed 42        547           sbc hl,bc 
02df 22 42 04     548           ld (ActiveDacCtr),hl 
02e2 ca f5 02     549           jp z,_enddac 
02e5 f2 fc 02     550           jp p,_nouflow
02e8 da f5 02     551           jp c,_enddac 
02eb              552           ; else dec adc+2 
02eb 2a 44 04     553           ld hl,(ActiveDacCtr+2) 
02ee 2b           554           dec hl 
02ef 22 44 04     555           ld (ActiveDacCtr+2),hl 
02f2              556         ; 4. IF ADC UNDERFLOWS, END DAC (or check loop if its there)
02f2 f2 fc 02     557           jp p,_nouflow ; if < 0, we're done with this. 
02f5              558 _enddac:
02f5 cd 1a 03     559           CALL QUICKSTOP
02f8 af           560           xor a 
02f9 32 9d 03     561           ld (DacTransferActive),a 
02fc              562 _nouflow: 
02fc c1           563          pop bc 
02fd e1           564         pop hl 
02fe              565 _daclpend:
02fe cd 73 06     566         call ZWAIT 
0301 3e 2b        567         ld a,$2b 
0303 32 00 40     568         ld ($4000),a
0306 cd 73 06     569         CALL ZWAIT  
0309 af           570         xor a
030a 32 01 40     571         ld ($4001),a 
030d              572         
030d 3a 4f 02     573         ld a,(DACWORK) 
0310 32 86 00     574         ld (RomBank),a 
0313 cd 25 06     575         call BANKSWAP 
0316 2a 51 02     576         ld hl,(DACWORK+2) 
0319              577         ; dont get next song byte outside the loop.
0319 c9           578         ret 
031a              579 ;;;;
031a              580 
031a              581 QUICKSTOP:
031a              582         
031a              583 ; TODO 
031a              584 ; get the active dac block (this is set inside the transfer each loop)
031a              585 ;  (ActiveDacBlock) is not used anywhere else
031a              586 ; set that block's "active" byte and counter to 0
031a 3a 41 04     587         ld a,(ActiveDacBlock)   ; ? 
031d e5           588         push hl 
031e c5           589          push bc 
031f cd 2a 04     590           call GETBLOCKSTRUCT
0322 01 0c 00     591           ld bc,12 ; +12 = ACTIVE BYTE 
0325 b7           592           or a 
0326 ed 4a        593           adc hl,bc 
0328 af           594           xor a 
0329 77           595           ld (hl),a 
032a              596           ;ld (DacTransferActive),a 
032a              597           ;ld (ActiveDacBank),a 
032a c1           598          pop bc 
032b e1           599         pop hl 
032c              600         ;?
032c 32 41 04     601         ld (ActiveDacBlock),a 
032f 32 42 04     602         ld (ActiveDacCtr),a 
0332 32 43 04     603         ld (ActiveDacCtr+1),a 
0335 32 44 04     604         ld (ActiveDacCtr+2),a 
0338 32 45 04     605         ld (ActiveDacCtr+3),a 
033b 32 46 04     606         ld (ActiveDacLoc),a 
033e 32 47 04     607         ld (ActiveDacLoc+1),a 
0341              608 ;       block transfer method takes care of turning off DAC mode 
0341 c9           609         RET 
0342              610 
0342              611 STOPDAC:
0342              612 ;;;;;;;;;;;;;;
0342              613 ; Stops DAC and disables DAC mode on CH6
0342              614 ; FIXME broken ?
0342 cd bc 01     615         call GetNextSongByte ; unused 
0345 af           616         xor a 
0346 32 9d 03     617         ld (DacTransferActive),a 
0349 32 48 04     618         ld (ActiveDacBank),a 
034c 32 41 04     619         ld (ActiveDacBlock),a 
034f 32 42 04     620         ld (ActiveDacCtr),a 
0352 32 43 04     621         ld (ActiveDacCtr+1),a 
0355 32 44 04     622         ld (ActiveDacCtr+2),a 
0358 32 45 04     623         ld (ActiveDacCtr+3),a 
035b 32 46 04     624         ld (ActiveDacLoc),a 
035e 32 47 04     625         ld (ActiveDacLoc+1),a 
0361 cd 73 06     626         call ZWAIT 
0364 3e 2b        627         ld a,$2b 
0366 32 00 40     628         ld ($4000),a 
0369 cd 73 06     629         call ZWAIT 
036c af           630         xor a 
036d 32 01 40     631         ld ($4001),a 
0370 c3 17 01     632         jp PLAYLOOP  
0373              633 ;;;
0373              634 
0373 00           635 StreamID: defb 0
0374              636 ; 90 0 2 0 2a 
0374              637 ; TODO SUPPORT MORE THAN ONE DAC STREAM :)
0374              638 DACSETUP:
0374              639         ;INC HL  ; STREAM ID 
0374 cd bc 01     640         call GetNextSongByte ; 0 
0377 7e           641         LD A,(HL) 
0378 32 73 03     642         LD (StreamID),A 
037b              643         ; We only want DAC mode on while transferring, so we leave that to
037b              644         ; the block transfer method
037b              645         ;INC HL  ; CHIP TYPE 
037b cd bc 01     646         call GetNextSongByte ; 2 
037e              647         ;LD A,(HL) ; for genesis this should only ever be 02
037e              648         ;CP 2
037e              649         ;JR NZ,fail
037e              650         ; I ignore these two bytes because VGM files appear to have
037e              651         ; discrepency over the byte order.
037e cd bc 01     652         call GetNextSongByte ; write this byte 
0381 cd bc 01     653         call GetNextSongByte ; to this reg
0384              654         
0384 c3 17 01     655         jp PLAYLOOP 
0387              656 
0387              657 SETDACSTREAM:        
0387              658 ; 0X91 <STREAM> <DATABANK ID> <STEP SIZE> <STEP BASE>
0387              659 ;         0           0            1           0 
0387              660 ; Preserves BC 
0387 c5           661        push bc 
0388 cd bc 01     662         call GetNextSongByte ; Stream ID is for multiple DAC channels.
038b              663         ; Genesis only supports one, so we skip it
038b cd bc 01     664         call GetNextSongByte ; Databank
038e              665         ; Set the active block
038e 7e           666         ld a,(hl) 
038f              667         ;ld (ActiveDacBlock),a 
038f              668         ; always call DAC TRANSFER every frame, but loop it through the 
038f              669         ;  data structs instead to find Active Byte = 1
038f              670         ;push hl 
038f              671          ;call GETBLOCKSTRUCT
038f              672          ;or a 
038f              673          ;ld bc,12 
038f              674          ;adc hl,bc 
038f              675          ;push hl 
038f              676          ;pop bc 
038f              677         ;pop hl   ; HL = song ptr, BC = address of block A active byte 
038f              678         ;LD A,1
038f              679         ;LD (BC),A 
038f              680 
038f cd bc 01     681         call GetNextSongByte ; always 1? (step)
0392 cd bc 01     682         call GetNextSongByte ; always 0? (step base)
0395 c1           683        pop bc 
0396              684 
0396 c3 17 01     685         jp PLAYLOOP  
0399              686 
0399              687 _invfreq
0399 88           688         defb $88
039a c3 9a 03     689 INVALIDFREQ: JP INVALIDFREQ 
039d              690 
039d              691 DacTransferActive: 
039d 00           692         defb 0
039e              693 DacFrequency:
039e 00 00        694         defb 0, 0
03a0              695 RealFrequency: 
03a0 00 00 00 00  696         defb 0,0,0,0
03a4              697 
03a4              698 
03a4              699 FreqTable:
03a4 86 00 b8 00 0b 01 70 01 15 02  700         DEFW 134,184,267,368,533
03ae              701 PALFreqTable:
03ae a0 00 dd 00 40 01 b9 01 80 02  702         DEFW 160,221,320,441,640
03b8              703 
03b8              704 ; $92
03b8              705 SETDACFREQ: ; 7D00 == 32000
03b8              706 ; 7D00 = 32000 = 533 N 640P ; 
03b8              707 ; 5622 = 22050 = 368 N 441P ; 
03b8              708 ; 3E80 = 16000 = 267 N 320P ; 
03b8              709 ; 2b11 = 11025 = 184 N 221P
03b8              710 ; 1f40 = 8000 =  134 N 160P
03b8              711 ;BREAKPOINT: JP BREAKPOINT
03b8 cd bc 01     712         call GetNextSongByte ; STREAM I
03bb cd bc 01     713         call GetNextSongByte ; LOW BYTE FREQ 
03be 7e           714         ld a,(hl) 
03bf 32 a0 03     715         ld (RealFrequency),a 
03c2 cd bc 01     716         call GetNextSongByte ; 8-15
03c5 7e           717         ld a,(hl) 
03c6 32 a1 03     718         ld (RealFrequency+1),a
03c9 cd bc 01     719         call GetNextSongByte ; byte 3
03cc cd bc 01     720         call GetNextSongByte ; byte 4
03cf              721 
03cf e5           722         push hl 
03d0 d5           723         push de 
03d1              724 
03d1 3a 88 00     725         ld a,(PALFlag)
03d4 fe 01        726         cp 1
03d6 20 05        727         jr nz,__2 
03d8 21 ae 03     728         ld hl,PALFreqTable
03db 18 03        729         jr __1
03dd              730 __2
03dd 21 a4 03     731         ld hl,FreqTable
03e0              732 __1
03e0              733 
03e0 3a a1 03     734         ld a,(RealFrequency+1)               ; high byte of real freq is all we care about        
03e3 fe 1f        735         cp $1f
03e5 28 13        736         jr z,_set8
03e7 fe 2b        737         cp $2b 
03e9 28 11        738         jr z,_set11
03eb fe 3e        739         cp $3e 
03ed 28 15        740         jr z,_set16 
03ef fe 56        741         cp $56 
03f1 28 19        742         jr z,_set22 
03f3 fe 7d        743         cp $7d 
03f5 28 1d        744         jr z,_set32 
03f7 c3 9a 03     745         jp INVALIDFREQ 
03fa              746 _set8:
03fa 18 1e        747         jr _endfset
03fc              748 _set11:
03fc b7           749         or a 
03fd 11 02 00     750         ld de,2 
0400 ed 5a        751         adc hl,de 
0402 18 16        752         jr _endfset
0404              753 _set16:
0404 b7           754         or a 
0405 11 04 00     755         ld de,4 
0408 ed 5a        756         adc hl,de 
040a 18 0e        757         jr _endfset
040c              758 _set22:
040c b7           759         or a 
040d 11 06 00     760         ld de,6 
0410 ed 5a        761         adc hl,de 
0412 18 06        762         jr _endfset
0414              763 _set32:
0414 b7           764         or a 
0415 11 08 00     765         ld de,8 
0418 ed 5a        766         adc hl,de 
041a              767 
041a              768 _endfset
041a 7e           769         ld a,(hl) 
041b 32 9e 03     770         ld (DacFrequency),a 
041e 23           771         inc hl 
041f 7e           772         ld a,(hl) 
0420 32 9f 03     773         ld (DacFrequency+1),a 
0423              774         
0423 d1           775         pop de
0424 e1           776         pop hl 
0425              777         ;call GetNextSongByte ; (theres an extra 0?)
0425              778 
0425 c3 17 01     779         jp PLAYLOOP 
0428              780 
0428              781 
0428              782 ;;;;;;;;;;;;;;;;;
0428              783 STARTDACSTREAM:
0428              784 ;        inc hl  ; stream id 
0428              785         ; TODO NOT USED IN MY EXAMPLES
0428 18 fe        786         JR STARTDACSTREAM
042a              787 
042a              788 GETBLOCKSTRUCT:
042a              789 ;;;;;;;;;;;;;;;;;;
042a              790 ; IN: [A]
042a              791 ; OUT: HL
042a              792 ; PRESERVES BC 
042a              793 ; * A H L 
042a c5           794         push bc 
042b 21 96 04     795         ld hl,DataType ; block 0 byte 0
042e cb 27        796         sla a ; * 2
0430 cb 27        797         sla a ; * 4
0432 cb 27        798         sla a ; * 8 
0434 cb 27        799         sla a ; * 16  ; we are 16 bytes large 
0436 85           800         add a,l   ; carry?
0437 6f           801         ld l,a 
0438 3e 00        802         ld a,0 
043a 4f           803         ld c,a 
043b 06 00        804         ld b,0   ; < this is to preserve carry 
043d ed 4a        805         adc hl,bc ; HL now has (DataType) + blockID*8
043f c1           806         pop bc 
0440 c9           807         RET 
0441              808 
0441              809 ; 95 00 (0-15) 00
0441 00           810 ActiveDacBlock: defb 0  ; which block 0-15 stored below
0442 00 00 00 00  811 ActiveDacCtr: defb 0,0,0,0 ; 32bit count
0446 00 00        812 ActiveDacLoc: defb 0,0  ; what is the memory offset
0448 00           813 ActiveDacBank: defb 0   ; which 68000 memory bank
0449 00           814 LoopDac: defb 0
044a              815 
044a              816 DACFASTCALL:
044a              817 ;;;;;;;;;;;;;;;;;;;;;;;;
044a              818 ; This should start the DAC playback
044a              819 ; 95 00 
044a              820 ; for data block info:
044a              821 ; data type 1
044a              822 ; datasize 4
044a              823 ; dataloc 2  (hl) 
044a              824 ; databank 1 (rom)
044a              825 ; datacounter 4 (bytes left this loop)
044a              826 ; blockactive 1 (gogogo)
044a              827 ; 0X95
044a cd bc 01     828         call GetNextSongByte ; STREAM ID - ALWAYS 0 FOR NOW
044d              829         
044d              830         ;ld a, 1
044d              831         ;ld (DacTransferActive),a  ; SET TRANSFER TO ACTIVE SO WE DO IT LOL
044d              832         
044d cd bc 01     833         call GetNextSongByte
0450 7e           834         ld a,(hl)       ; [A] contains block ID 
0451              835         ;add a,a 
0451              836         ;jr nz, _nope  ; FIXME: ONE STREAM FOR NOW
0451              837         ; warning! only have ram for 0-15!
0451 32 41 04     838         ld (ActiveDacBlock),a ; low byte 
0454 e5           839         push hl 
0455 cd 2a 04     840          call GETBLOCKSTRUCT
0458 e5           841          push HL 
0459 c1           842          pop bc ; put it in BC
045a e1           843         pop hl ; recover song pointer 
045b cd bc 01     844         call GetNextSongByte ; block ID high 8 bits - skip this 
045e              845         ;ld a,(bc) ; data type
045e 03           846         INC BC 
045f 03           847         INC BC 
0460 03           848         INC BC 
0461 03           849         INC BC  ; SKIP FOUR SIZE BYTES
0462              850 
0462 03           851         inc bc 
0463 0a           852         ld a,(bc) 
0464              853 ;        LD E,4 
0464              854 ;        ADD A,E 
0464 32 46 04     855         ld (ActiveDacLoc),a 
0467 03           856         inc bc         
0468 0a           857         ld a,(bc)
0469              858 ;        ADC A,0 
0469 32 47 04     859         ld (ActiveDacLoc+1),a ; 16bit dac offset ;a1e0
046c              860 
046c 03           861         inc bc 
046d 0a           862         ld a,(bc) ; data rom bank #
046e 32 48 04     863         ld (ActiveDacBank),a 
0471              864 
0471 03           865         inc bc 
0472 0a           866         ld a,(bc) ; CTR+0
0473 32 42 04     867         ld (ActiveDacCtr),a 
0476 03           868         inc bc 
0477 0a           869         ld a,(bc) 
0478 32 43 04     870         ld (ActiveDacCtr+1),a 
047b 03           871         inc bc 
047c 0a           872         ld a,(bc) 
047d 32 44 04     873         ld (ActiveDacCtr+2),a 
0480 03           874         inc bc 
0481 0a           875         ld a,(bc) 
0482 32 45 04     876         ld (ActiveDacCtr+3),a ; store 32bit dac size
0485              877 
0485 03           878         inc bc 
0486 3e 01        879         ld a,1
0488 02           880         ld (bc),a 
0489              881 
0489              882         ;INC HL          ; FLAGS 
0489 cd bc 01     883         call GetNextSongByte
048c 7e           884         ld a, (hl)      ; AM I LOOPING?
048d 32 49 04     885         ld (LoopDac),a  ; FIXME - NO LOOP FOR NOW
0490              886         ; enable!
0490 c3 17 01     887         jp PLAYLOOP 
0493              888 _nope: 
0493              889         ;call GetNextSongByte
0493              890         ;call GetNextSongByte
0493 c3 17 01     891         jp PLAYLOOP
0496              892 
0496              893 ; Data Block struct:
0496 ff           894 DataType: defb $ff
0497 00 00 00 00  895 DataSize: defb 0,0,0,0
049b 00 00        896 DataLoc: defb 0,0
049d 00           897 DataBank: defb 0
049e 00 00 00 00  898 DataCounter: defb 0,0,0,0 
04a2 00           899 BlockActive: defb 0
04a3 00 00 00     900 _buffer: defb 0,0,0          ; 16 bytes 
04a6              901 ;Type (ff means empty) 1
04a6              902 ; Compatible types:
04a6              903 ; 0: YM2612 PCM data 
04a6              904 ;Size 4
04a6              905 ; 32 bit size (from VGM file)
04a6              906 ;Loc 2 (HL offset of data start)
04a6              907 ;Bank 1 (bank of data start)
04a6              908 ;Counter 4 (32bit offset remaining to play of this loop)
04a6              909 ;BlockActive: 1 if we need to dac stream it, 0 skips
04a6              910 ;_buffer 3 : to align to 16 bytes
04a6 ff 00 00 00 00 00 00 00  911 Block1: defb $ff,0,0,0,0,0,0,0
04ae 00 00 00 00 00 00 00 00  912         defb $0,0,0,0,0,0,0,0
04b6 ff 00 00 00 00 00 00 00  913 Block2: defb $ff,0,0,0,0,0,0,0
04be 00 00 00 00 00 00 00 00  914         defb $0,0,0,0,0,0,0,0
04c6 ff 00 00 00 00 00 00 00  915 Block3: defb $ff,0,0,0,0,0,0,0
04ce 00 00 00 00 00 00 00 00  916         defb $0,0,0,0,0,0,0,0
04d6 ff 00 00 00 00 00 00 00  917 Block4: defb $ff,0,0,0,0,0,0,0
04de 00 00 00 00 00 00 00 00  918         defb $0,0,0,0,0,0,0,0
04e6 ff 00 00 00 00 00 00 00  919 Block5: defb $ff,0,0,0,0,0,0,0
04ee 00 00 00 00 00 00 00 00  920         defb $0,0,0,0,0,0,0,0
04f6 ff 00 00 00 00 00 00 00  921 Block6: defb $ff,0,0,0,0,0,0,0
04fe 00 00 00 00 00 00 00 00  922         defb $0,0,0,0,0,0,0,0
0506 ff 00 00 00 00 00 00 00  923 Block7: defb $ff,0,0,0,0,0,0,0
050e 00 00 00 00 00 00 00 00  924         defb $0,0,0,0,0,0,0,0
0516 ff 00 00 00 00 00 00 00  925 Block8: defb $ff,0,0,0,0,0,0,0
051e 00 00 00 00 00 00 00 00  926         defb $0,0,0,0,0,0,0,0
0526 ff 00 00 00 00 00 00 00  927 Block9: defb $ff,0,0,0,0,0,0,0
052e 00 00 00 00 00 00 00 00  928         defb $0,0,0,0,0,0,0,0
0536 ff 00 00 00 00 00 00 00  929 Block10: defb $ff,0,0,0,0,0,0,0
053e 00 00 00 00 00 00 00 00  930         defb $0,0,0,0,0,0,0,0
0546 ff 00 00 00 00 00 00 00  931 Block11: defb $ff,0,0,0,0,0,0,0
054e 00 00 00 00 00 00 00 00  932         defb $0,0,0,0,0,0,0,0
0556 ff 00 00 00 00 00 00 00  933 Block12: defb $ff,0,0,0,0,0,0,0
055e 00 00 00 00 00 00 00 00  934         defb $0,0,0,0,0,0,0,0
0566 ff 00 00 00 00 00 00 00  935 Block13: defb $ff,0,0,0,0,0,0,0
056e 00 00 00 00 00 00 00 00  936         defb $0,0,0,0,0,0,0,0
0576 ff 00 00 00 00 00 00 00  937 Block14: defb $ff,0,0,0,0,0,0,0
057e 00 00 00 00 00 00 00 00  938         defb $0,0,0,0,0,0,0,0
0586 ff 00 00 00 00 00 00 00  939 Block15: defb $ff,0,0,0,0,0,0,0
058e 00 00 00 00 00 00 00 00  940         defb $0,0,0,0,0,0,0,0
0596              941 
0596              942 
0596              943 DATABLOCK:
0596              944 ;;;;;;;;;;;;
0596              945 ;
0596 cd bc 01     946         call GetNextSongByte ; should be 0x66
0599 7e           947         ld a,(hl) 
059a              948         ; find an empty block of pointers
059a e5           949         push hl ;9f43 = 66
059b 21 86 04     950          ld hl,DataType-16
059e 01 10 00     951          ld bc,16      ; 16 BYTES IN SIZE 
05a1              952 _blockfind:
05a1 af           953          xor a 
05a2 ed 4a        954          adc hl,bc 
05a4 7e           955          ld a,(hl)    ; hl += 16
05a5 fe ff        956          cp $ff 
05a7 28 02        957          jr z,_blockok 
05a9 18 f6        958          jr _blockfind 
05ab              959 _blockok:         
05ab e5           960          push hl 
05ac c1           961          pop bc ; now BC has block struct pointer. 
05ad e1           962         pop hl                  
05ae              963 
05ae              964 ; FIXME I dont work with empty data blocks.
05ae cd bc 01     965         call GetNextSongByte
05b1 7e           966         ld a,(hl) 
05b2 02           967         ld (bc),a  ; data type  ; = 0
05b3 cd bc 01     968         call GetNextSongByte
05b6              969         ; TODO: Check data type
05b6 03           970         inc bc 
05b7 7e           971         ld a,(hl)  ; 9f45 = 77
05b8 02           972         ld (bc),a ; data size
05b9 32 29 00     973         ld (WORKRAM),a 
05bc cd bc 01     974         call GetNextSongByte
05bf              975         
05bf 7e           976         ld a,(hl)
05c0 03           977         inc bc  
05c1 02           978         ld (bc),a ; data size+1 = 0c
05c2 32 2a 00     979         ld (WORKRAM+1),a 
05c5 cd bc 01     980         call GetNextSongByte
05c8              981         
05c8 03           982         inc bc 
05c9 7e           983         ld a,(hl) 
05ca 02           984         ld (bc),a ; data size+2 = 00
05cb 32 2b 00     985         ld (WORKRAM+2),a 
05ce cd bc 01     986         call GetNextSongByte
05d1              987         
05d1 03           988         inc bc 
05d2 7e           989         ld a,(hl) 
05d3 02           990         ld (bc),a ; data size+3 = 00
05d4 32 2c 00     991         ld (WORKRAM+3),a 
05d7              992         
05d7              993         ; now store HL, which is right before data start...
05d7 03           994         inc bc 
05d8 7d           995         ld a,l   ; dataloc l...
05d9 02           996         ld (bc),a 
05da              997         
05da 7c           998         ld a,h   ; and h
05db              999         ;and $7f 
05db 03          1000         inc bc 
05dc 02          1001         ld (bc),a ;
05dd             1002         
05dd 3a 86 00    1003         ld a,(RomBank) 
05e0 03          1004         inc bc     ; DataBank
05e1 02          1005         ld (bc),a ; and store current rom bank, cuz this must be where it starts
05e2 32 dd 01    1006         ld (ZadrWork),a 
05e5 af          1007         xor a 
05e6 32 de 01    1008         ld (ZadrWork+1),a 
05e9 22 df 01    1009         ld (ZadrWork+2),hl ; 0, 0, 9a9f ( = 1a9f)
05ec             1010 ;Counter 4 (32bit offset remaining to play of this loop)
05ec 2a 29 00    1011         ld hl,(WORKRAM) 
05ef 7d          1012         ld a,l 
05f0 03          1013         inc bc     ; ctr+0
05f1 02          1014         ld (bc),a 
05f2 7c          1015         ld a,h 
05f3 03          1016         inc bc 
05f4 02          1017         ld (bc),a  ; ctr+1 
05f5 2a 2b 00    1018         ld hl,(WORKRAM+2) 
05f8 7d          1019         ld a,l 
05f9 03          1020         inc bc   ; ctr+2
05fa 02          1021         ld (bc),a 
05fb 7c          1022         ld a,h 
05fc 03          1023         inc bc 
05fd 02          1024         ld (bc),a  ; ctr+3 
05fe             1025         ; BlockActive starts at 0, we set it to 1 when we hit FASTCALL. 
05fe             1026         ; so ignore the rest.
05fe             1027 
05fe             1028         ; NEW FUNCTION: Get 68000 address from current bank/HL
05fe cd 1d 02    1029         call GETROMADDRESS
0601             1030         ; ZadrWork = 32bit address of data bank start 
0601             1031         ; WORKRAM = data size 
0601             1032         ; add WORKRAM to ZadrWork
0601 2a dd 01    1033         ld hl,(ZadrWork) ; 
0604 ed 4b 29 00 1034         ld bc,(WORKRAM)  ; data size low 16 
0608 b7          1035         or a 
0609 ed 4a       1036         adc hl,bc ; check carry 
060b 22 dd 01    1037         ld (ZadrWork),hl ; save low 16
060e 2a df 01    1038         ld hl,(ZadrWork+2) 
0611 01 00 00    1039         ld bc,$0000
0614 ed 4a       1040         adc hl,bc  ; ok  ; carry is cleared here)
0616 ed 4b 2b 00 1041         ld bc,(WORKRAM+2) 
061a ed 4a       1042         adc hl,bc  ; upper 16
061c 22 df 01    1043         ld (ZadrWork+2),hl 
061f cd e1 01    1044         call SETZADDRESS  ; s
0622             1045         ; now our song pointer and rom window should be
0622             1046         ; at the byte following the data block -1.
0622             1047 
0622             1048 _compressed: ; TODO do extra stuff for compressed data
0622             1049 _uncompressed:
0622 c3 17 01    1050         jp PLAYLOOP     
0625             1051 
0625             1052 
0625             1053 BANKSWAP:
0625             1054 ;;;;;;;;;;;;;
0625             1055 ; * A (preserve bc)
0625             1056 ; RomBank has the # of the 32kb block to write to 6001.
0625             1057 ;  Keep it 8 bits for now FIXME for > 8MB song locations 
0625 c5          1058         push bc 
0626 0e 01       1059         ld c, 1         ; = 0b00000001
0628 b7          1060         or a 
0629             1061 _bswp2: 
0629 3a 86 00    1062         ld a,(RomBank)
062c a1          1063         and c 
062d fe 00       1064         cp 0 
062f 28 02       1065         jr z,_bzero 
0631 18 06       1066         jr _bone
0633             1067 _bzero: 
0633 cd 73 06    1068         call ZWAIT 
0636 af          1069         xor a 
0637 18 05       1070         jr _bwrt 
0639             1071 _bone:
0639 cd 73 06    1072         call ZWAIT 
063c 3e 01       1073         ld a,1
063e             1074 _bwrt:
063e 32 01 60    1075         ld ($6001),a 
0641 cb 21       1076         sla c           ; = 0b00000010
0643 30 e4       1077         jr nc,_bswp2    ; loop until bit goes into carry
0645             1078 
0645 cd 73 06    1079         call ZWAIT 
0648 af          1080         xor a 
0649 32 01 60    1081         ld ($6001),a       ; 9 bit = 0 ( works for < 8MB)
064c c1          1082         pop bc 
064d c9          1083         ret 
064e             1084 ;;;;
064e             1085 
064e             1086 BANKUP:
064e             1087 ;;;;;;;;;;;;;;
064e             1088 ; * A H L
064e             1089 ; Pops up the rom bank by 1 and 
064e             1090 ; sets HL back to $8000
064e 3a 86 00    1091         ld a,(RomBank) 
0651 3c          1092         inc a 
0652 32 86 00    1093         ld (RomBank),a 
0655 cd 25 06    1094         call BANKSWAP 
0658 21 00 80    1095         ld hl,$8000
065b c9          1096         ret 
065c             1097 ;;;;
065c             1098 
065c             1099 
065c             1100 WRITEFM1:
065c             1101 ;;;;;;;;;;;;;;;;;;;
065c             1102 ; HL - location of song byte
065c             1103 ; * A  
065c cd bc 01    1104         call GetNextSongByte ; register 
065f cd 73 06    1105         CALL ZWAIT 
0662 7e          1106         LD A,(HL) 
0663 32 00 40    1107         LD (FMREG0),A
0666 cd bc 01    1108         call GetNextSongByte ; data byte 
0669 cd 73 06    1109         CALL ZWAIT  
066c 7e          1110         LD A,(HL) 
066d 32 01 40    1111         LD (FMDAT0),A 
0670 c3 17 01    1112         JP PLAYLOOP
0673             1113 ;;;;
0673             1114 
0673             1115 ZWAIT:
0673             1116 ;;;;;;;;;;;;;;;;;;
0673             1117 ; * A C
0673 3a 00 40    1118         LD A,($4000) 
0676 87          1119         ADD A, A 
0677 38 fa       1120         JR C,ZWAIT   
0679 c9          1121         RET 
067a             1122 ;;;;
067a             1123 
067a             1124 WRITEFM2:
067a             1125 ;;;;;;;;;;;;;;;;
067a             1126 ; HL = song byte
067a             1127 ; * A
067a cd bc 01    1128         call GetNextSongByte
067d cd 73 06    1129         CALL ZWAIT 
0680 7e          1130         LD A,(HL) 
0681 32 02 40    1131         LD (FMREG1),A 
0684 cd bc 01    1132         call GetNextSongByte
0687 cd 73 06    1133         CALL ZWAIT 
068a 7e          1134         LD A,(HL) 
068b 32 03 40    1135         LD (FMDAT1),A 
068e c3 17 01    1136         JP PLAYLOOP 
0691             1137 ;;;;
0691             1138 
0691             1139 WRITEPSG:
0691             1140 ;;;;;;;;;;;;;;;;
0691             1141 ; HL = song byte 
0691             1142 ; * A
0691 cd bc 01    1143         call GetNextSongByte
0694 cd 73 06    1144         CALL ZWAIT 
0697 7e          1145         LD A,(HL) 
0698 32 11 7f    1146         ld (PSGREG),a 
069b c3 17 01    1147         JP PLAYLOOP 
069e             1148 ;;;;
069e             1149 
069e             1150 
069e             1151 
069e             1152 SAMPLEWAIT:
069e             1153 ;;;;;;;;;;;
069e             1154 ; * A, B, C
069e             1155 ; HL = song byte 
069e cd bc 01    1156         call GetNextSongByte
06a1 7e          1157         LD A,(HL)
06a2 4f          1158         LD C,A  
06a3 cd bc 01    1159         call GetNextSongByte
06a6 7e          1160         LD A,(HL)
06a7 47          1161         LD B,A          ; BC = SAMPLE WAIT 16BIT
06a8             1162 _sampwt:
06a8 3a 80 00    1163         LD A,(PlayNext)  ; check the 'play next frame' var
06ab fe 01       1164         CP 1             ; is it = 1?
06ad 20 f9       1165         JR NZ,_sampwt    ; if not, wait until frame is over
06af cd 53 02    1166         CALL DACBLOCKTRANSFER
06b2 af          1167         xor a
06b3 32 80 00    1168         ld (PlayNext),a  ; clear play var
06b6             1169         ; subtract 735 from BC 
06b6 e5          1170         push hl         ; save song pointer
06b7 c5          1171           push bc       ; sample wait value:
06b8 e1          1172           pop hl        ; bc to hl 
06b9 3a 88 00    1173          ld a,(PALFlag) 
06bc fe 01       1174          cp 1 
06be 20 05       1175          jr nz,_palsize
06c0 01 df 02    1176          ld bc,735      ; NTSC
06c3 18 03       1177          jr __3
06c5             1178 _palsize 
06c5 01 72 03    1179          ld bc,882      ; PAL
06c8             1180 __3 
06c8 ed 42       1181          sbc hl,bc      ; samplewait - 735 -> HL
06ca e5          1182          push hl 
06cb c1          1183          pop bc         ; store it back in bc 
06cc e1          1184         pop hl          ; recover song pointer
06cd 30 d9       1185         jr nc,_sampwt   ; wait another frame if samplewait is still > 0
06cf             1186 
06cf c3 17 01    1187         JP PLAYLOOP 
06d2             1188 ;;;;
06d2             1189 
06d2             1190 
06d2             1191 CLEARPSG:
06d2             1192 ;;;;;;;;;;;;;;;;;;;;
06d2             1193 ; clear the SSG (mute)
06d2             1194 ; * A, B (preserve HL)
06d2 e5          1195         push hl 
06d3 21 20 00    1196         LD HL,CLRTB 
06d6 06 04       1197         ld b,4
06d8             1198 _clearlp:
06d8 7e          1199         ld a,(hl) 
06d9 32 11 7f    1200         ld (PSGREG),a 
06dc cd bc 01    1201         call GetNextSongByte
06df 10 f7       1202         djnz _clearlp
06e1 e1          1203         pop hl 
06e2 c9          1204         RET
06e3             1205 ;;;;
1684 bytes code generated and 144 labels defined
